{"version":3,"file":"pspdfkit-lib/chunk-server-ef590910ecaba72a.js","mappings":"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","sources":["webpack://PSPDFKit/./src/lib/ServerBackend/ServerBackendState.ts","webpack://PSPDFKit/./src/lib/requests/types/XHRImageRequest.ts","webpack://PSPDFKit/./src/lib/ServerBackend/ServerBackend.ts","webpack://PSPDFKit/./src/utils/load.ts","webpack://PSPDFKit/./src/lib/ServerBackend/authentication.ts","webpack://PSPDFKit/./src/lib/ServerBackend/hostedAuthentication.ts","webpack://PSPDFKit/./src/lib/SharedBackend.ts","webpack://PSPDFKit/./src/lib/requests/RequestQueue.ts","webpack://PSPDFKit/./src/models/EmbeddedFile.ts","webpack://PSPDFKit/./src/lib/serializers/EmbeddedFileSerializer.ts","webpack://PSPDFKit/./src/models/InstantSettings.ts","webpack://PSPDFKit/./src/utils/documentOperations.ts","webpack://PSPDFKit/./src/utils/search.ts"],"sourcesContent":["import * as Immutable from 'immutable'\nimport { List } from 'immutable'\nimport BackendPermissions from '@/models/BackendPermissions'\nimport {\n  ISignatureFeatureAvailability,\n  SignatureFeatureAvailability,\n} from '@/enums/SignatureFeatureAvailability'\nimport type { SignaturesInfo } from '@/models/digital-signatures/SignaturesInfo'\nimport type { InstantSettings } from '@/models/InstantSettings'\nimport { ILicenseFeature } from '@/enums/LicenseFeature'\n\ninterface IServerBackendState {\n  authPayload:\n    | {\n        jwt: string\n      }\n    | {\n        accessToken: string\n      }\n    | null\n  serverUrl: string | null\n  hostedBaseUrl: string | null\n  documentId: string | null\n  backendPermissions: BackendPermissions | null\n  documentURL: string | null\n  imageToken: string | null\n  token: string | null\n  instantSettings: InstantSettings | null\n  features: List<string>\n  signatureFeatureAvailability: ISignatureFeatureAvailability\n  isFormsEnabled: boolean\n  documentHandle: string | null\n  isDocumentHandleOutdated: boolean\n  digitalSignatures: SignaturesInfo | null\n  defaultGroup: string | null | undefined\n  hasCollaborationPermissions: boolean\n  forceLegacySignaturesFeature: boolean\n  minSearchQueryLength: number\n}\n\nexport default class ServerBackendState extends Immutable.Record<IServerBackendState>({\n  authPayload: null,\n  serverUrl: null,\n  hostedBaseUrl: null,\n  documentId: null,\n  backendPermissions: null,\n  documentURL: null,\n  imageToken: null,\n  instantSettings: null,\n  token: null,\n  features: List(),\n  signatureFeatureAvailability: SignatureFeatureAvailability.NONE,\n  isFormsEnabled: true,\n  minSearchQueryLength: 1,\n  documentHandle: null,\n  isDocumentHandleOutdated: false,\n  digitalSignatures: null,\n  defaultGroup: undefined,\n  hasCollaborationPermissions: false,\n  forceLegacySignaturesFeature: false,\n}) {\n  /**\n   * The auth payload used to create the PSPDFKit for Web instance. This is most likely an object\n   * with a key `jwt` that contains the `jwt`.\n   * We also use a special internal authentication token for the PSPDFKit Server dashboard, this\n   * also creates an object here with the key `jwt` but the value is no valid JWT!\n   * Hosted viewer uses a separate `accessToken` to authenticate with the hosted frontend.\n   */\n  override authPayload:\n    | {\n        jwt: string\n      }\n    | {\n        accessToken: string\n      }\n\n  /**\n   * URL to the PSPDFKit Server, e.g: `https://pspdfkit.example.com/`\n   */\n  override serverUrl: string\n\n  /**\n   * URL of the hosted frontend, e.g: `https://api.pspdfkit.com/`\n   */\n  override hostedBaseUrl: string\n\n  /**\n   * The identifier of the document for PSPDFKit Server\n   */\n  override documentId: string\n\n  /**\n   * Defines if the user is allowed to edit annotations or download the document\n   */\n  override backendPermissions: BackendPermissions\n\n  /**\n   * URL to the document, e.g.: `https://pspdfkit.example.com/d/foobar`\n   */\n  override documentURL: string\n\n  /**\n   * This token is used to retrieve images from the Server.\n   */\n  override imageToken: string\n\n  /**\n   * The write token generated by PSPDFKit Server. This is used to authenticate all non image\n   * loading requests.\n   */\n  override token: string\n\n  /**\n   * Holds settings for the instant provider. When present, InstantProvider is used to\n   * communicate with the Server.\n   */\n  override instantSettings: InstantSettings\n\n  /**\n   * PSPDFKit license features, used to detect which features can be used.\n   */\n  override features: List<ILicenseFeature>\n\n  /**\n   * Determines which variant of signatures UI is shown\n   */\n  override signatureFeatureAvailability: ISignatureFeatureAvailability\n\n  /**\n   * Scans the Configuration and the returned features to see if forms shall be implemented. This is\n   * necessary since we initialize the RESTProvider before we can process this information in\n   * other parts of the app.\n   *\n   * FIXME: Find a way to get the actual licenses when initializing RESTProvider so that we don't\n   * have to maintain a separate implementation of form related feature tests.\n   */\n  override isFormsEnabled: boolean\n\n  /**\n   * ID string corresponding to the current document. This field is updated when operations\n   * are applied on the document with the new document SHA256 hash.\n   */\n  override documentHandle: string\n\n  /**\n   * Set when the document has been modified by an external client, thereby modifying the document handle.\n   * When set, the backend should authenticate again and load the modified document with the new `documentHandle`.\n   */\n  override isDocumentHandleOutdated: boolean\n\n  /**\n   * List of digital signatures present in the document.\n   */\n  override digitalSignatures: SignaturesInfo\n\n  /**\n   * Set the default group to use when records are created through the UI\n   */\n  override defaultGroup: string | null | undefined\n\n  /**\n   * Whether Collaboration Permissions are enabled or not\n   */\n  override hasCollaborationPermissions: boolean\n\n  /**\n   * Marks if even though Electronic Signatures licensed for the current user,\n   * the legacy signature mode should be used instead.\n   */\n  override forceLegacySignaturesFeature: boolean\n}\n","import { Request } from './Request'\nimport { requestIsSuccess } from '@/utils/http'\nimport { webp } from '@/utils/features'\nimport { PSPDFKitError } from '@pspdfkit/shared'\nimport ImageHandle from '../../handles/ImageHandle'\nimport { getVersionHeader } from '@/utils/environment'\n\nconst GENERIC_RENDER_ERROR = 'The image can not be rendered because of an unknown error.'\n\nexport default class XHRImageRequest implements Request {\n  identifier: string\n  token: string\n  url: string\n  payload: any\n  httpRequest?: XMLHttpRequest\n  doNotRequestWebP: boolean\n\n  constructor({\n    identifier,\n    url,\n    token,\n    payload,\n    doNotRequestWebP = false,\n  }: {\n    identifier: string\n    url: string\n    token: string\n    payload?: any\n    doNotRequestWebP?: boolean\n  }) {\n    this.identifier = identifier\n    this.url = url\n    this.token = token\n    this.payload = payload\n    this.doNotRequestWebP = doNotRequestWebP\n  }\n\n  abort(): void {\n    this.httpRequest?.abort()\n  }\n\n  request(): Promise<\n    | ImageHandle<HTMLImageElement>\n    | {\n        attachmentsNotFound: Array<string>\n      }\n  > {\n    return new Promise((resolve, reject) => {\n      const httpRequest = new XMLHttpRequest()\n\n      this.httpRequest = httpRequest\n      httpRequest.open(this.payload ? 'POST' : 'GET', this.url, true)\n      httpRequest.setRequestHeader('X-PSPDFKit-Image-Token', this.token)\n      httpRequest.setRequestHeader('PSPDFKit-Platform', 'web')\n      httpRequest.setRequestHeader('PSPDFKit-Version', getVersionHeader())\n\n      if (webp && !this.doNotRequestWebP) {\n        httpRequest.setRequestHeader('Accept', 'image/webp,*/*')\n      }\n\n      httpRequest.responseType = 'blob'\n\n      // We need to use the spec conform `onreadystatechange` since `onload` and `onerror` behaves\n      // differently in our test environment\n      // @TODO inspect what's causing the context of the arrow function to change\n      httpRequest.onreadystatechange = (async () => {\n        // request finished and response is ready\n        if (httpRequest.readyState !== 4) {\n          return\n        }\n\n        // response.type can include charset info, so we only check it begins with application/json\n        if (httpRequest.response && httpRequest.response.type.startsWith('application/json')) {\n          // We have to read the blob here using a FileReader since we configure the http request as\n          // a blob one.\n          const fileReader = new FileReader()\n\n          fileReader.onload = event => {\n            const response = JSON.parse(event.target?.result as string)\n\n            if (response.attachments_not_found) {\n              resolve({\n                attachmentsNotFound: response.attachments_not_found,\n              })\n            } else if (response.error) {\n              reject(\n                new PSPDFKitError(\n                  `The server could not render the requested image (${response.error})`,\n                ),\n              )\n            } else {\n              reject(new PSPDFKitError(GENERIC_RENDER_ERROR))\n            }\n          }\n\n          fileReader.onerror = () => reject(new PSPDFKitError(GENERIC_RENDER_ERROR))\n\n          fileReader.readAsText(httpRequest.response)\n\n          return\n        }\n\n        if (!requestIsSuccess(httpRequest.status)) {\n          reject(new PSPDFKitError(GENERIC_RENDER_ERROR))\n\n          return\n        }\n\n        const blob = httpRequest.response\n        const objectUrl = URL.createObjectURL(blob)\n        const img = new Image()\n\n        img.onerror = () => reject(new PSPDFKitError(GENERIC_RENDER_ERROR))\n\n        img.src = objectUrl\n\n        await img.decode()\n        resolve(new ImageHandle(img, () => URL.revokeObjectURL(objectUrl)))\n      }).bind(this)\n\n      httpRequest.send(this.payload)\n    })\n  }\n}\n","import { authenticate } from './authentication'\nimport { authenticateHostedDocument } from './hostedAuthentication'\nimport BackendPermissions from '@/models/BackendPermissions'\nimport WidgetAnnotation from '@/models/annotations/WidgetAnnotation'\nimport { fromJSON as documentOutlineFromJSON } from '../serializers/OutlineElementSerializer'\nimport { getBaseUrl, getVersionHeader } from '@/utils/environment'\nimport { isCacheableAnnotationAPStream, isModifiableAnnotation } from '@/utils/annotation'\nimport { jsonToTextLines } from '@/utils/textLines'\nimport { List } from 'immutable'\nimport { MAX_RESOURCE_REQUESTS_IN_QUEUE_SERVER, MAX_WEBP_DIMENSION } from '@/constants/config'\nimport { parseJsonSearchResults, SearchResultJSON } from '@/utils/search'\nimport { PSPDFKitError, warn, isPlainObject } from '@pspdfkit/shared'\nimport { rectToJSON } from '../serializers/rect'\nimport {\n  serializeAnnotation,\n  serializeFormFieldValue,\n  serializeFormField,\n  deserializeSignaturesInfo,\n} from '../serializers/utils'\nimport { validateDocumentAccessToken, validateJWT } from '@/utils/load'\nimport JSONRequest from '../requests/types/JSONRequest'\nimport RequestQueue from '../requests/RequestQueue'\nimport ServerBackendState from './ServerBackendState'\nimport XHRImageRequest from '../requests/types/XHRImageRequest'\nimport { ulid } from 'ulid'\nimport { addBlobToWeakMap } from '@/utils/documentOperations'\nimport { defaultInstantSettings } from '@/models/InstantSettings'\nimport RedactionAnnotationSerializer from '../serializers/RedactionAnnotationSerializer'\nimport { SearchType } from '@/enums/SearchType'\nimport { SharedBackend } from '../SharedBackend'\nimport { SignatureFeatureAvailability } from '@/enums/SignatureFeatureAvailability'\nimport { invariant } from '@pspdfkit/shared'\nimport { EmbeddedFile } from '@/models/EmbeddedFile'\nimport { fromJSON } from '@/lib/serializers/EmbeddedFileSerializer'\nimport { imageHandleFromBlob } from '@/utils/dom'\nimport { supportsFormDataInResponse } from '@/utils/features'\nimport { formFieldValueFromFormField } from '@/utils/forms'\nimport { LicenseFeature } from '@/enums/LicenseFeature'\nimport { validateHostedBaseUrl } from '@/utils/http'\nimport * as ContentEditorTypes from '@/core/ContentEditorTypes'\nimport { RenderTileContentState } from '@/typings/backend'\nimport { hasWebAnnotationEditingFeature } from '@/utils/permissions'\n\nimport type { DiscardablePromise } from '@/utils/promise'\nimport type { ISearchType } from '@/enums/SearchType'\nimport type { IFunction } from '@/typings/utils'\nimport type { ISearchPattern } from '@/enums/SearchPattern'\nimport type { Size, Rect } from '@/models'\nimport type FormFieldValue from '@/models/form-fields/FormFieldValue'\nimport type ImageHandle from '../handles/ImageHandle'\nimport type { Annotation } from '@/models'\nimport type {\n  DocumentResponse,\n  TextResponse,\n  BackendType,\n  LoadResponse,\n  ExportPDFFlags,\n  GetPDFURLFlags,\n  GeneratePDFObjectURLFlags,\n  LoadOptions,\n  FormResponse,\n} from '@/typings/backend'\nimport type { ActionChange } from '@/models/actions/Action'\nimport type { DocumentOperationJSON } from '@/models/DocumentOperation'\nimport type { InstantJSON } from '../InstantJSON'\nimport type { ServerConfiguration } from '@/Configuration'\nimport type OutlineElement from '@/models/OutlineElement'\nimport type SearchResult from '@/models/search/SearchResult'\nimport type { TwoStepSignatureCallback } from '@/models/digital-signatures/TwoStepSignatureCallback'\nimport type { SignaturesInfo } from '@/models/digital-signatures/SignaturesInfo'\nimport type { SignaturePreparationData } from '@/models/digital-signatures/SignaturePreparationData'\nimport type { SigningServiceData } from '@/models/digital-signatures/SigningServiceData'\nimport type { RESTProvider } from '../RESTProvider/RESTProvider'\nimport type { InstantProvider } from '../InstantProvider/InstantProvider'\nimport type { InstantSettings } from '@/models/InstantSettings'\nimport type { RedactionAnnotationPreset } from '@/models/RedactionAnnotationPreset'\nimport type { ReadStateProviderCallbacks } from '../ReadStateProvider'\nimport type { FormFieldValueJSON } from '@/typings/json/formFieldValue'\n\n/**\nThis type can be used to control rendering in relation to print.\n\nWhen printing, annotation's `noView` and `noPrint` flags have to be honoured\naccording to the PDF spec:\n\n- An annotation with the noView flag will not be rendered in the UI but may be printable.\n- An annotation with the noPrint flag will not be printed.\n\nFrom: https://pspdfkit.com/guides/web/current/annotations/annotation-flags/\n */\ntype RenderForPrinting = boolean\n\nexport default class ServerBackend extends SharedBackend {\n  provider: RESTProvider | InstantProvider\n  _state: ServerBackendState\n  _requestQueue: RequestQueue\n  _password: string | null | undefined = null\n  _refreshSignaturesInfoPromise: Promise<void> | null | undefined\n  type: BackendType = 'SERVER'\n\n  constructor(configuration: ServerConfiguration, _window: Window = window) {\n    super()\n\n    // Validate authPayload is an object\n    if (!(typeof configuration.authPayload === 'object')) {\n      throw new PSPDFKitError(\n        \"authPayload must be an object that contains the `jwt`. For example: `authPayload: { jwt: 'xxx.xxx.xxx'}`\",\n      )\n    }\n\n    const accessToken = configuration.authPayload?.accessToken\n\n    let serverUrl: string | null = null\n    let documentUrl: string | null = null\n    let hostedBaseUrl: string | null = null\n\n    if (!accessToken) {\n      serverUrl = resolveServerUrl(configuration, _window)\n\n      // Validate document ID\n      if (typeof configuration.documentId !== 'string') {\n        throw new PSPDFKitError('`documentId` must be of type string.')\n      }\n\n      documentUrl = `${serverUrl}i/d/${configuration.documentId}`\n\n      // Validate authPayload\n      // noinspection SuspiciousTypeOfGuard\n      if (\n        !(\n          typeof configuration.authPayload === 'object' &&\n          'jwt' in configuration.authPayload &&\n          typeof configuration.authPayload.jwt === 'string'\n        )\n      ) {\n        throw new PSPDFKitError(\n          \"authPayload must be an object that contains the `jwt`. For example: `authPayload: { jwt: 'xxx.xxx.xxx'}`\",\n        )\n      }\n\n      validateJWT(configuration.authPayload.jwt)\n    } else {\n      hostedBaseUrl = configuration.hostedBaseUrl || 'https://api.pspdfkit.com/'\n      validateHostedBaseUrl(hostedBaseUrl)\n\n      validateDocumentAccessToken(accessToken)\n    }\n\n    validateInstantSetting(configuration.instant)\n\n    let instantSettings: InstantSettings | null | undefined = null\n\n    if (configuration.instant) {\n      if (isPlainObject(configuration.instant)) {\n        const settings = configuration.instant\n\n        instantSettings = {\n          clientsPresenceEnabled: settings.clientsPresenceEnabled !== false,\n          listenToServerChangesEnabled: settings.listenToServerChangesEnabled !== false,\n        }\n      } else {\n        instantSettings = defaultInstantSettings\n      }\n    }\n\n    this._requestQueue = new RequestQueue(MAX_RESOURCE_REQUESTS_IN_QUEUE_SERVER)\n\n    const forceLegacySignaturesFeature = configuration.electronicSignatures\n      ? Boolean(configuration.electronicSignatures.forceLegacySignaturesFeature)\n      : false\n\n    this._state = new ServerBackendState({\n      serverUrl,\n      hostedBaseUrl: hostedBaseUrl,\n      documentId: configuration.documentId,\n      instantSettings: instantSettings,\n      documentURL: documentUrl,\n      authPayload: configuration.authPayload,\n      isFormsEnabled: !configuration.disableForms,\n      forceLegacySignaturesFeature,\n    })\n\n    if (configuration['trustedCAsCallback']) {\n      // TODO: Add link to guide article on Server\n      warn(\n        'PSPDFKit.Configuration#trustedCAsCallback is only used on Standalone deployments. On a Server-backed deployment, please follow the instructions at https://pspdfkit.com/guides/web',\n      )\n    }\n  }\n\n  isUsingInstantProvider(): boolean {\n    return this._state.instantSettings != null\n  }\n\n  hasClientsPresence() {\n    const instantSettings = this._state.instantSettings\n\n    return instantSettings != null && instantSettings.clientsPresenceEnabled !== false\n  }\n\n  async load(options: LoadOptions = {}): Promise<LoadResponse> {\n    await this.tryAuthenticateHostedViewer()\n\n    const {\n      imageToken,\n      token,\n      permissions,\n      features,\n      signatureFeatureAvailability,\n      hasPassword,\n      minSearchQueryLength,\n      layerHandle,\n      allowedTileScales,\n      digitalSignatures,\n      defaultGroup,\n      collaborationPermissions,\n      creatorName,\n    } = await authenticate(\n      `${this._state.serverUrl}i/d/${this._state.documentId}`,\n      this._state.authPayload as { jwt: string },\n      options.password,\n    )\n\n    // Keep for reloading after applying operations\n    this._password = options.password\n\n    // check for Instant feature enabled in license if configured for Instant\n    if (this._state.instantSettings && !features.includes(LicenseFeature.INSTANT)) {\n      throw new PSPDFKitError(`Instant feature is not enabled on this server. Please set \\`instant\\` to \\`false\\`.\n\nFor more information about PSPDFKit Instant please visit:\nhttps://pspdfkit.com/guides/web/current/instant/overview/`)\n    }\n\n    const finalSignatureFeatureAvailability =\n      signatureFeatureAvailability === SignatureFeatureAvailability.ELECTRONIC_SIGNATURES &&\n      hasWebAnnotationEditingFeature(features) &&\n      this._state.forceLegacySignaturesFeature\n        ? SignatureFeatureAvailability.LEGACY_SIGNATURES\n        : signatureFeatureAvailability\n\n    this._state = this._state.withMutations(state => {\n      return state\n        .set('imageToken', imageToken)\n        .set('token', token)\n        .set('features', List(features))\n        .set('signatureFeatureAvailability', finalSignatureFeatureAvailability)\n        .set(\n          'backendPermissions',\n          new BackendPermissions({\n            readOnly: permissions.indexOf('write') === -1,\n            downloadingAllowed: permissions.indexOf('download') >= 0,\n          }),\n        )\n        .set(\n          'documentURL',\n          `${this._state.serverUrl}i/d/${this._state.documentId}/h/${layerHandle}`,\n        )\n        .set('documentHandle', layerHandle)\n        .set('isDocumentHandleOutdated', false)\n        .set('digitalSignatures', deserializeSignaturesInfo(digitalSignatures))\n    })\n\n    if (!!collaborationPermissions && !this._state.instantSettings) {\n      throw new PSPDFKitError(\n        'Collaboration Permissions is not supported when `instant` is disabled. Please make sure `configuration#instant` is set to `true`.',\n      )\n    }\n\n    this._state = this._state.withMutations(state => {\n      state.defaultGroup = defaultGroup\n      state.hasCollaborationPermissions = Boolean(collaborationPermissions)\n    })\n\n    if (this.provider) {\n      this.provider.destroy()\n    }\n\n    this.provider = await this._initProvider()\n    this._state.instantSettings &&\n      this.provider.setDocumentHandleConflictCallback(this.handleDocumentHandleConflict)\n\n    return {\n      features: this._state.features,\n      signatureFeatureAvailability: this._state.signatureFeatureAvailability,\n      hasPassword,\n      minSearchQueryLength,\n      allowedTileScales,\n      creatorName,\n      defaultGroup,\n    }\n  }\n\n  private async tryAuthenticateHostedViewer() {\n    if ('accessToken' in this._state.authPayload) {\n      const { hostedBaseUrl } = this._state\n      const accessToken = this._state.authPayload.accessToken\n\n      const { serverUrl, serverId, jwt } = await authenticateHostedDocument(\n        hostedBaseUrl,\n        accessToken,\n      )\n\n      this._state = this._state.withMutations(state => {\n        state\n          .set('serverUrl', serverUrl)\n          .set('documentId', serverId)\n          .set('documentURL', `${serverUrl}i/d/${serverId}`)\n          .set('authPayload', { jwt })\n      })\n    }\n  }\n\n  async _initProvider(): Promise<RESTProvider | InstantProvider> {\n    if (this._state.instantSettings) {\n      const documentURL = `${this._state.serverUrl}i/d/${this._state.documentId}/h/${this._state.documentHandle}`\n      const { InstantProvider } = await import(\n        /* webpackChunkName: \"server-instant\" */\n        '../InstantProvider/InstantProvider'\n      )\n\n      return new InstantProvider(\n        `${this._state.serverUrl}i/d/${this._state.documentId}`,\n        documentURL,\n        {\n          auth_token: this._state.token,\n        },\n        this._state.instantSettings,\n      )\n    } else {\n      const isFormsEnabled =\n        this._state.isFormsEnabled && this._state.features.includes(LicenseFeature.FORMS)\n\n      const { RESTProvider } = await import(\n        /* webpackChunkName: \"server-rest\" */\n        '../RESTProvider/RESTProvider'\n      )\n\n      return new RESTProvider(\n        this._state.documentURL,\n        {\n          token: this._state.token,\n        },\n        {\n          isFormsEnabled,\n        },\n      )\n    }\n  }\n\n  destroy(): void {\n    this._destroyProvider()\n\n    this._requestQueue && this._requestQueue.destroy()\n  }\n\n  documentInfo(): Promise<DocumentResponse> {\n    return this._fetch(`${this._state.documentURL}/document.json`)\n      .then(res => res.json())\n      .then(payload => payload.data)\n  }\n\n  getFormJSON(): Promise<FormResponse> {\n    return this._fetch(`${this._state.documentURL}/form.json`).then(res => {\n      if (res.status === 403) {\n        return {\n          v: 1,\n          type: 'pspdfkit/form',\n          annotations: [],\n          fields: [],\n        }\n      } else {\n        return res.json().then(json => {\n          const formResponse: FormResponse = json.data\n\n          return formResponse\n        })\n      }\n    })\n  }\n\n  async evalFormValuesActions() {\n    throw new Error('not implemented')\n  }\n\n  async evalScript() {\n    throw new Error('not implemented')\n  }\n\n  async setFormJSONUpdateBatchMode() {\n    throw new Error('not implemented')\n  }\n\n  permissions(): Promise<BackendPermissions> {\n    return Promise.resolve(this._state.backendPermissions)\n  }\n\n  getDefaultGroup(): string | null | undefined {\n    return this._state.defaultGroup\n  }\n\n  isCollaborationPermissionsEnabled() {\n    return this._state.hasCollaborationPermissions\n  }\n\n  textForPageIndex(pageIndex: number): {\n    promise: Promise<TextResponse>\n    cancel: IFunction\n  } {\n    const pageTextRequestURL = `${this._state.documentURL}/page-${pageIndex}-text`\n    const jsonRequestPromise = new (this._getJSONRequestHandler())(\n      pageTextRequestURL,\n      this._state.token,\n    )\n\n    const request = this._requestQueue.enqueue(jsonRequestPromise, true)\n\n    const jsonRequestQueuePromise = request.promise.then(json => jsonToTextLines(json, pageIndex))\n\n    return {\n      promise: jsonRequestQueuePromise,\n      cancel: () => {\n        request.cancel()\n      },\n    }\n  }\n\n  getTextFromRects(pageIndex: number, rects: List<Rect>): Promise<string> {\n    const rectsParam = encodeURIComponent(JSON.stringify(rects.map(rectToJSON).toArray()))\n\n    return this._fetch(\n      `${this._state.documentURL}/page-${pageIndex}-highlighted?rects=${rectsParam}`,\n    )\n      .then(res => res.json())\n      .then(response => response.text)\n  }\n\n  _getJSONRequestHandler() {\n    return JSONRequest\n  }\n\n  renderTile(\n    pageIndex: number,\n    pageSize: Size,\n    tileRect: Rect,\n    renderForPrinting: RenderForPrinting,\n    _renderText: boolean,\n    contentState?: RenderTileContentState,\n  ): {\n    promise: Promise<ImageHandle<HTMLImageElement | HTMLCanvasElement>>\n    cancel: IFunction\n  } {\n    if (this._state.isDocumentHandleOutdated) {\n      return {\n        promise: new Promise(() => {}),\n        cancel: () => {},\n      }\n    }\n\n    const imageTileURL = `${this._state.documentURL}/page-${pageIndex}-dimensions-${\n      pageSize.width\n    }-${pageSize.height}-tile-${tileRect.left}-${tileRect.top}-${tileRect.width}-${\n      tileRect.height\n    }${renderForPrinting ? '-print' : ''}`\n    const hasPriority = pageSize.width === tileRect.width && pageSize.height === tileRect.height\n    const doNotRequestWebP =\n      tileRect.width > MAX_WEBP_DIMENSION || tileRect.height > MAX_WEBP_DIMENSION\n    let resolvePromise,\n      rejectPromise,\n      isCanceled = false,\n      hasRetried = false,\n      // eslint-disable-next-line prefer-const\n      requestPromises: any = [],\n      // eslint-disable-next-line prefer-const\n      requestImages: any[] = []\n\n    const promise = new Promise<ImageHandle<HTMLImageElement>>((resolve, reject) => {\n      resolvePromise = resolve\n      rejectPromise = reject\n    })\n\n    const requestTile = (includeAttachmentIds: Array<string> = []) => {\n      let imageRequestPromise\n\n      if (contentState) {\n        const formData = new FormData()\n\n        formData.append(\n          'data',\n          JSON.stringify({\n            annotations: contentState.annotations\n              .filter(isModifiableAnnotation)\n              .map(serializeAnnotation)\n              .toJS()\n              .map(content => ({\n                content,\n              })),\n            formFieldValues: contentState.formFieldValues.map(serializeFormFieldValue).toJS(),\n            formFields: contentState.formFields.map(serializeFormField).toJS(),\n            signatures: contentState.signatures || [],\n          }),\n        )\n\n        if (includeAttachmentIds.length > 0) {\n          includeAttachmentIds.forEach(id => {\n            const attachment = contentState.attachments.get(id)\n\n            invariant(attachment && attachment.data, 'Attachment data could not be found.')\n            formData.append(id, attachment.data)\n          })\n        }\n\n        imageRequestPromise = new XHRImageRequest({\n          identifier: imageTileURL,\n          url: imageTileURL,\n          token: this._state.imageToken,\n          payload: formData,\n          doNotRequestWebP,\n        })\n      } else {\n        imageRequestPromise = new XHRImageRequest({\n          identifier: imageTileURL,\n          url: imageTileURL,\n          token: this._state.imageToken,\n          doNotRequestWebP,\n        })\n      }\n\n      requestImages.push(imageRequestPromise)\n\n      const imageRequest = this._requestQueue.enqueue(imageRequestPromise, hasPriority)\n\n      imageRequest.promise\n        .then(tile => {\n          if (isCanceled) {\n            return\n          }\n\n          if (tile.attachmentsNotFound && !hasRetried) {\n            hasRetried = true\n            requestTile(tile.attachmentsNotFound)\n\n            return\n          }\n\n          if (tile.attachmentsNotFound) {\n            rejectPromise(new PSPDFKitError('Attachment could not be found.'))\n\n            return\n          }\n\n          resolvePromise(tile)\n        })\n        .catch(error => {\n          if (isCanceled) {\n            return\n          }\n\n          rejectPromise(error)\n        })\n      requestPromises.push(imageRequest)\n    }\n\n    requestTile()\n\n    return {\n      promise,\n      cancel: () => {\n        isCanceled = true\n        requestImages.forEach(request => {\n          if (request.abort && typeof request.abort === 'function') request.abort()\n        })\n        requestPromises.forEach(request => {\n          request.cancel()\n        })\n      },\n    }\n  }\n\n  /**\n   * Common method for renderAnnotation and renderDetachedAnnotation.\n   */\n  _requestRenderAnnotation = (\n    annotation: Annotation,\n    formFieldValue: FormFieldValue | null | undefined,\n    blob: Blob | null | undefined,\n    width: number,\n    height: number,\n    detached?: boolean,\n  ) => {\n    const renderAnnotationURL = `${this._state.documentURL}/render_annotation`\n    const requestQueueId = `render-annotation-${detached ? ulid() : annotation.id}`\n    const annotationJSON = JSON.stringify({\n      data: serializeAnnotation(annotation),\n      width: width,\n      height: height,\n      detached: detached || undefined,\n      formFieldValue: formFieldValue ? serializeFormFieldValue(formFieldValue) : undefined,\n    })\n    let resolvePromise,\n      rejectPromise,\n      isCanceled = false,\n      // eslint-disable-next-line prefer-const\n      hasRetried = false,\n      // eslint-disable-next-line prefer-const\n      requestPromises: any[] = []\n    const promise = new Promise((resolve, reject) => {\n      resolvePromise = resolve\n      rejectPromise = reject\n    })\n\n    const requestAnnotation = (includeAttachmentIds: Array<string> = []) => {\n      const formData = new FormData()\n\n      formData.append('render', annotationJSON)\n\n      if (includeAttachmentIds.length > 0 && annotation.imageAttachmentId && blob) {\n        formData.append(annotation.imageAttachmentId, blob)\n      }\n\n      const doNotRequestWebP = width > MAX_WEBP_DIMENSION || height > MAX_WEBP_DIMENSION\n      const imageRequestPromise = new XHRImageRequest({\n        identifier: requestQueueId,\n        url: renderAnnotationURL,\n        token: this._state.imageToken,\n        payload: formData,\n        doNotRequestWebP,\n      })\n\n      const imageRequest = this._requestQueue.enqueue(imageRequestPromise, false)\n\n      imageRequest.promise\n        .then(result => {\n          if (isCanceled) {\n            return\n          }\n\n          if (result.attachmentsNotFound && !hasRetried) {\n            requestAnnotation(result.attachmentsNotFound)\n\n            return\n          }\n\n          if (result.attachmentsNotFound) {\n            rejectPromise(new PSPDFKitError('Attachment could not be found.'))\n\n            return\n          }\n\n          resolvePromise(result)\n        })\n        .catch(error => {\n          if (isCanceled) {\n            return\n          }\n\n          rejectPromise(error)\n        })\n      requestPromises.push(imageRequest)\n    }\n\n    requestAnnotation()\n\n    return {\n      promise,\n      cancel: () => {\n        isCanceled = true\n        requestPromises.forEach(request => {\n          request.cancel()\n        })\n      },\n    }\n  }\n\n  _requestRenderAnnotations = (\n    pageIndex: number,\n    annotationsPdfObjectIds: Array<number>,\n    widths: Array<number>,\n    heights: Array<number>,\n    formFieldValues: Array<FormFieldValueJSON>,\n  ): DiscardablePromise<Array<Blob | null | undefined>> => {\n    const renderAnnotationsURL = `${this._state.documentURL}/render_annotations`\n\n    const renderRequestJSON = JSON.stringify({\n      annotations: annotationsPdfObjectIds.map((pdfObjectId, index) => ({\n        pageIndex,\n        pdfObjectId,\n        width: widths[index],\n        height: heights[index],\n      })),\n      formFieldValues,\n    })\n\n    let resolvePromise\n    let rejectPromise\n    let isCanceled = false\n\n    const promise = new Promise<Array<Blob | null | undefined>>((resolve, reject) => {\n      resolvePromise = resolve\n      rejectPromise = reject\n    })\n\n    this._fetch(renderAnnotationsURL, {\n      method: 'post',\n      body: renderRequestJSON,\n      credentials: 'include',\n      headers: {\n        'X-PSPDFKit-Image-Token': this._state.imageToken,\n        'Content-Type': 'application/json',\n        Accept: 'multipart/form-data',\n      },\n    })\n\n      .then(res => res.formData())\n      .then((result: FormData) => {\n        if (isCanceled) {\n          return\n        }\n\n        resolvePromise(Array.from(result.values()))\n      })\n      .catch(error => {\n        if (isCanceled) {\n          return\n        }\n\n        rejectPromise(error)\n      })\n\n    return {\n      promise,\n      cancel: () => {\n        isCanceled = true\n      },\n    }\n  }\n\n  renderAnnotation(\n    annotation: Annotation,\n    formFieldValue: FormFieldValue | null | undefined,\n    blob: Blob | null | undefined,\n    width: number,\n    height: number,\n  ): {\n    promise: Promise<ImageHandle<HTMLImageElement> | null | undefined>\n    cancel: IFunction\n  } {\n    // @ts-expect-error\n    return this._requestRenderAnnotation(annotation, formFieldValue, blob, width, height)\n  }\n\n  async renderPageAnnotations(\n    pageIndex: number,\n    unfilteredAnnotations: List<Annotation>,\n    scaleFactor: number,\n  ): Promise<void> {\n    if (!supportsFormDataInResponse) {\n      // If formData() in responses is not (or not correctly) supported, fall back to individual AP stream rendering.\n      const pageAPStreamsPromise = Promise.resolve()\n\n      this.pageAPStreamsPromises = this.pageAPStreamsPromises.set(pageIndex, pageAPStreamsPromise)\n\n      return pageAPStreamsPromise\n    }\n\n    const provider = this.provider\n\n    const hasWidgets = unfilteredAnnotations.some(\n      annotation => annotation instanceof WidgetAnnotation,\n    )\n\n    if (hasWidgets) {\n      await provider._setReadStateCallbacksPromise\n    }\n\n    const formFieldValues: Array<FormFieldValueJSON> = []\n\n    // Filter out stamps, image and signature widgets, which do not get cached.\n    const annotations = unfilteredAnnotations.filter(annotation => {\n      const annotationWithFormField = hasWidgets\n        ? (provider._readStateCallbacks as ReadStateProviderCallbacks).getAnnotationWithFormField(\n            annotation.id,\n          )\n        : null\n      const formField = annotationWithFormField?.formField\n\n      const isCacheable = isCacheableAnnotationAPStream(annotation, formField)\n\n      if (isCacheable && formField && typeof annotation.pdfObjectId === 'number') {\n        const formFieldValueForFormField = formFieldValues.find(\n          formFieldValue => formFieldValue.name === formField.name,\n        )\n\n        if (!formFieldValueForFormField) {\n          formFieldValues.push(serializeFormFieldValue(formFieldValueFromFormField(formField)))\n        }\n      }\n\n      return isCacheable && typeof annotation.pdfObjectId === 'number'\n    })\n\n    if (annotations.size === 0 && formFieldValues.length === 0) {\n      return Promise.resolve()\n    }\n\n    const pageAPStreamsPromise = new Promise<void>((resolve, reject) => {\n      const { promise: renderPageAnnotationsCall, cancel } = this._requestRenderAnnotations(\n        pageIndex,\n        annotations.map(annotation => annotation.pdfObjectId).toArray() as number[],\n        annotations\n          .map(annotation => Math.floor(annotation.boundingBox.width * scaleFactor))\n          .toArray(),\n        annotations\n          .map(annotation => Math.floor(annotation.boundingBox.height * scaleFactor))\n          .toArray(),\n        formFieldValues,\n      )\n\n      renderPageAnnotationsCall\n        .then((pageAPStreamsBlobs: Array<Blob | null | undefined>) => {\n          // An array of blob with PNG images is received.\n          const imageHandlePromises: Array<\n            Promise<ImageHandle<HTMLImageElement>> | null | undefined\n          > = pageAPStreamsBlobs.map(blob => blob && imageHandleFromBlob(blob))\n\n          imageHandlePromises.forEach(async (imageHandlePromise, index) => {\n            const imageHandle = await imageHandlePromise\n            const annotation: Annotation | undefined = annotations.get(index)\n\n            if (annotation) {\n              const annotationAPStreamPromiseResolve = this.annotationAPStreamPromises.get(\n                annotation.id,\n              )\n\n              // If there's a registered resolve callback, resolve with the imageHandle\n              if (annotationAPStreamPromiseResolve) {\n                this.annotationAPStreamPromises = this.annotationAPStreamPromises.delete(\n                  annotation.id,\n                )\n                annotationAPStreamPromiseResolve(imageHandle)\n              }\n\n              // Cache the imageHandle\n              imageHandle && this.cacheAPStream(imageHandle, annotation)\n            }\n          })\n          Promise.all(imageHandlePromises).then(() => resolve())\n        })\n        .catch(error => {\n          cancel()\n          reject(error)\n        })\n    })\n\n    // Store the promise so when cachedRenderAnnotation() is called, it can be awaited to ensure AP streams are available for rendering.\n    this.pageAPStreamsPromises = this.pageAPStreamsPromises.set(pageIndex, pageAPStreamsPromise)\n\n    return pageAPStreamsPromise\n  }\n\n  renderDetachedAnnotation(\n    annotation: Annotation,\n    blob: Blob | null | undefined,\n    width: number,\n    height: number,\n  ): {\n    promise: Promise<ImageHandle<HTMLImageElement | HTMLCanvasElement> | null | undefined>\n    cancel: IFunction\n  } {\n    // @ts-expect-error\n    return this._requestRenderAnnotation(annotation, null, blob, width, height, true)\n  }\n\n  async getAttachment(attachmentId: string): Promise<Blob> {\n    try {\n      const res = await this._fetch(`${this._state.documentURL}/attachments/${attachmentId}`)\n\n      switch (res.status) {\n        case 404:\n          throw new PSPDFKitError('Attachment not Found.')\n\n        case 200:\n          return await res.blob()\n\n        default:\n          throw new PSPDFKitError('Bad Request.')\n      }\n    } catch (error) {\n      throw new PSPDFKitError(`Could not fetch attachment from PSPDFKit Server. ${error}`)\n    }\n  }\n\n  async search(\n    searchTerm: string,\n    startPageIndex: number,\n    limitPages: number,\n    caseSensitive: boolean,\n    searchInAnnotations = false,\n    searchType: ISearchType = SearchType.TEXT,\n  ): Promise<List<SearchResult>> {\n    const params = `q=${\n      searchType === SearchType.PRESET\n        ? searchTerm.replace(/_/g, '-')\n        : encodeURIComponent(searchTerm)\n    }&start=${startPageIndex}&limit=${limitPages}&type=${searchType}&include_annotations=${searchInAnnotations.toString()}&case_sensitive=${caseSensitive.toString()}`\n    const url = `${this._state.documentURL}/search?${params}`\n    const response = await new JSONRequest(url, this._state.token).request<{\n      data: SearchResultJSON[]\n    }>()\n\n    return parseJsonSearchResults(response.data)\n  }\n\n  async getMeasurementSnappingPoints(_pageIndex: number) {\n    // TODO - implement\n  }\n\n  async searchAndRedact(\n    term: string | ISearchPattern,\n    options: {\n      searchType: ISearchType\n      searchInAnnotations: boolean\n      caseSensitive: boolean\n      annotationPreset: RedactionAnnotationPreset\n    },\n  ): Promise<List<Annotation>> {\n    const { searchType, annotationPreset, searchInAnnotations, caseSensitive } = options\n    const { color, fillColor, outlineColor, ...rest } = annotationPreset\n    const res = await this._fetch(`${this._state.documentURL}/redactions`, {\n      method: 'post',\n      credentials: 'include',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        strategy: searchType,\n        strategyOptions: {\n          [searchType as string]: searchType === SearchType.PRESET ? term.replace(/_/g, '-') : term,\n          includeAnnotations: searchInAnnotations,\n          caseSensitive: caseSensitive,\n        },\n        content: {\n          ...rest,\n          color: color && color.toHex(),\n          fillColor: fillColor && fillColor.toHex(),\n          outlineColor: outlineColor && outlineColor.toHex(),\n        },\n      }),\n    })\n    const { data } = await res.json()\n\n    return List(\n      data && data.annotations\n        ? data.annotations.map(ann => RedactionAnnotationSerializer.fromJSON(ann.id, ann.content))\n        : [],\n    )\n  }\n\n  exportPDF({\n    flatten = false,\n    includeComments = true,\n    excludeAnnotations = false,\n  }: ExportPDFFlags = {}): Promise<ArrayBuffer> {\n    const url = `${this._state.documentURL}/pdf?token=${this._state.token}&flatten=${String(\n      flatten,\n    )}&comments=${String(includeComments)}&render_ap_streams=${String(\n      !flatten,\n    )}&remove_annotations=${String(excludeAnnotations)}`\n\n    return fetch(url, {\n      method: 'GET',\n      credentials: 'include',\n    }).then(r => r.arrayBuffer())\n  }\n\n  exportXFDF(): Promise<string> {\n    return this._fetch(`${this._state.documentURL}/document.xfdf`).then(res => res.text())\n  }\n\n  exportInstantJSON(): Promise<InstantJSON> {\n    return this._fetch(`${this._state.documentURL}/instant.json`).then(res => res.json())\n  }\n\n  getPDFURL({ includeComments = true, excludeAnnotations = false }: GetPDFURLFlags = {}): {\n    promise: Promise<string>\n    revoke: IFunction\n  } {\n    return {\n      promise: Promise.resolve(\n        `${this._state.documentURL}/pdf?token=${this._state.token}&flatten=true&comments=${String(\n          includeComments,\n        )}&remove_annotations=${String(excludeAnnotations)}`,\n      ),\n      revoke: () => {},\n    }\n  }\n\n  generatePDFObjectURL({\n    includeComments = true,\n    excludeAnnotations = false,\n  }: GeneratePDFObjectURLFlags = {}): {\n    promise: Promise<string>\n    revoke: IFunction\n  } {\n    let objectUrl,\n      isRevoked = false\n    const promise = new Promise<string>(resolve => {\n      this.exportPDF({\n        flatten: true,\n        includeComments,\n        excludeAnnotations,\n      }).then(arrayBuffer => {\n        if (isRevoked) {\n          return\n        }\n\n        const blob = new Blob([arrayBuffer], {\n          type: 'application/pdf',\n        })\n\n        objectUrl = window.URL.createObjectURL(blob)\n        resolve(objectUrl)\n      })\n    })\n\n    return {\n      promise,\n      revoke: () => {\n        if (objectUrl) {\n          window.URL.revokeObjectURL(objectUrl)\n        }\n\n        isRevoked = true\n      },\n    }\n  }\n\n  async getDocumentOutline(): Promise<List<OutlineElement>> {\n    let data\n\n    try {\n      const json = await this._fetch(`${this._state.documentURL}/outline.json`).then(res =>\n        res.json(),\n      )\n\n      data = json.data\n    } catch (e) {\n      data = {}\n    }\n\n    const outline = Array.isArray(data.outline) ? data.outline : []\n\n    return List(outline.map(documentOutlineFromJSON))\n  }\n\n  onKeystrokeEvent(): Promise<Array<ActionChange>> {\n    throw new Error('not implemented')\n  }\n\n  async applyOperationsAndReload(operations: Array<DocumentOperationJSON>): Promise<LoadResponse> {\n    try {\n      const body = await createOperationsPayload(operations)\n\n      this._destroyProvider()\n\n      await this._fetch(`${this._state.documentURL}/apply-operations`, {\n        method: 'post',\n        body,\n        credentials: 'include',\n      })\n    } catch (e) {\n      throw new PSPDFKitError(`Applying operations failed: ${e}`)\n    }\n\n    return this.reloadDocument()\n  }\n\n  async applyRedactionsAndReload(): Promise<LoadResponse> {\n    try {\n      this._destroyProvider()\n\n      await this._fetch(`${this._state.documentURL}/redact`, {\n        method: 'post',\n        credentials: 'include',\n      })\n\n      return this.reloadDocument()\n    } catch (e) {\n      // We rollback from destroying the provider if redacting fails. Otherwise,\n      // no further updates are sent to the current provider.\n      this.provider.load()\n      throw new PSPDFKitError(`Applying redactions failed: ${e}`)\n    }\n  }\n\n  async reloadDocument(): Promise<LoadResponse> {\n    try {\n      return await this.load({\n        password: this._password,\n      })\n    } catch (e) {\n      throw new PSPDFKitError(`Reloading the document failed: ${e}`)\n    }\n  }\n\n  async exportPDFWithOperations(operations: Array<DocumentOperationJSON>): Promise<ArrayBuffer> {\n    try {\n      const body = await createOperationsPayload(operations)\n\n      return this._fetch(`${this._state.documentURL}/pdf-with-operations`, {\n        method: 'post',\n        body,\n        credentials: 'include',\n      }).then(res => res.arrayBuffer())\n    } catch (e) {\n      throw new PSPDFKitError(`Exporting PDF with operations failed: ${e}`)\n    }\n  }\n\n  async getSignaturesInfo(): Promise<SignaturesInfo> {\n    if (this._refreshSignaturesInfoPromise) {\n      await this._refreshSignaturesInfoPromise\n    }\n\n    return this._state.digitalSignatures\n  }\n\n  refreshSignaturesInfo(): Promise<void> {\n    if (this._refreshSignaturesInfoPromise) {\n      return this._refreshSignaturesInfoPromise\n    }\n\n    this._refreshSignaturesInfoPromise = new Promise((resolve, reject) => {\n      this._fetch(`${this._state.documentURL}/signatures`, {\n        method: 'get',\n        credentials: 'include',\n      })\n        .then(res => res.json())\n        .then(({ data: digitalSignatures }) => {\n          this._state = this._state.set(\n            'digitalSignatures',\n            deserializeSignaturesInfo(digitalSignatures),\n          )\n          this._refreshSignaturesInfoPromise = null\n          resolve()\n        })\n        .catch(error => {\n          this._state = this._state.set('digitalSignatures', null)\n          this._refreshSignaturesInfoPromise = null\n          reject(error)\n        })\n    })\n\n    return this._refreshSignaturesInfoPromise\n  }\n\n  async signDocumentAndReload(\n    signaturePreparationData: SignaturePreparationData | null | undefined,\n    signingServiceData: TwoStepSignatureCallback | (SigningServiceData | null | undefined),\n  ): Promise<void> {\n    try {\n      if (signingServiceData !== undefined && typeof signingServiceData !== 'object') {\n        throw new PSPDFKitError('Signing service data must be an object if specified.')\n      }\n\n      const additionalParams: any = {}\n\n      if (signaturePreparationData && 'placeholderSize' in signaturePreparationData) {\n        additionalParams.signerDataSource = {\n          estimatedSize: signaturePreparationData.placeholderSize,\n        }\n      }\n\n      if (signaturePreparationData && 'flatten' in signaturePreparationData) {\n        additionalParams.flatten = signaturePreparationData.flatten\n      }\n\n      const body = {\n        ...(signingServiceData\n          ? {\n              signingToken: signingServiceData.signingToken,\n            }\n          : null),\n        ...additionalParams,\n      }\n\n      // We destroy the provider because during signing, a new form field and\n      // widget annotation are created. Afterwards, we reload the document and\n      // update the layerHandle, bailing out from the changes propagation back\n      // to the managers flow.\n      this._destroyProvider()\n\n      await this._fetch(`${this._state.documentURL}/sign`, {\n        method: 'post',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(body),\n        credentials: 'include',\n      })\n      await this.reloadDocument()\n    } catch (e) {\n      // We rollback from destroying the provider if signing fails. Otherwise,\n      // no further updates are sent to the current provider.\n      this.provider.load()\n      throw new PSPDFKitError(`Adding digital signature failed: ${e.message || e}`)\n    }\n  }\n\n  handleDocumentHandleConflict = () => {\n    this._state = this._state.set('isDocumentHandleOutdated', true)\n    this.cancelRequests()\n\n    this._destroyProvider()\n  }\n\n  getDocumentHandle() {\n    return this._state.documentHandle\n  }\n\n  async getEmbeddedFiles(): Promise<List<EmbeddedFile>> {\n    const res = await this._fetch(`${this._state.documentURL}/embedded-files`, {\n      method: 'get',\n      credentials: 'include',\n    })\n\n    const data = await res.json()\n\n    return List(\n      data?.data?.embeddedFiles?.length\n        ? data.data.embeddedFiles.map(({ id, content }) => fromJSON(id, content))\n        : [],\n    )\n  }\n\n  // Cancels all current requests and removes all associated promises.\n  cancelRequests() {\n    this._requestQueue.cancelAll()\n  }\n\n  _destroyProvider() {\n    if (this.provider) {\n      // @ts-expect-error\n      this.provider._clients && this.provider._clients.disconnect()\n      this.provider.destroy()\n    }\n  }\n\n  async _fetch(url: string, options?: RequestInit): Promise<Response> {\n    const response = await fetch(url, {\n      ...options,\n      headers: {\n        ...options?.headers,\n        'X-PSPDFKit-Token': this._state.token,\n        'PSPDFKit-Platform': 'web',\n        'PSPDFKit-Version': getVersionHeader(),\n      },\n    })\n\n    if (!response.ok) {\n      let bodyMessage = await parseAsJSONOrString(response)\n\n      bodyMessage = typeof bodyMessage === 'object' ? bodyMessage.reason : bodyMessage\n\n      const message = bodyMessage || `${response.status} ${response.statusText}`\n\n      throw new PSPDFKitError(message)\n    }\n\n    return response\n  }\n\n  syncChanges(): Promise<void> {\n    return this.provider.syncChanges()\n  }\n\n  // No-op in Server mode.\n  async clearAPStreamCache(): Promise<void> {}\n\n  async runPDFFormattingScripts(): Promise<ActionChange[]> {\n    return []\n  }\n\n  // We don't require any lazy loading in Server.\n  async lazyLoadPages(): Promise<void> {}\n\n  async contentEditorEnter(): Promise<void> {\n    throw new Error('not implemented')\n  }\n\n  async contentEditorExit(): Promise<void> {\n    throw new Error('not implemented')\n  }\n\n  async contentEditorGetTextBlocks(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _pageIndex: number,\n  ): Promise<ContentEditorTypes.InitialTextBlock[]> {\n    throw new Error('not implemented')\n  }\n\n  async contentEditorRenderTextBlock(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _textBlockId: string,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _renderTextBlockParams: ContentEditorTypes.RenderTextBlockParams,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _externalControlState: ContentEditorTypes.ExternalControlState,\n  ): Promise<ContentEditorTypes.TextBlockRenderResult> {\n    throw new Error('not implemented')\n  }\n\n  contentEditorSetTextBlockCursor(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _textBlockId: string,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _offset: ContentEditorTypes.Vec2,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _selectText: boolean,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _externalControlState: ContentEditorTypes.ExternalControlState,\n  ): Promise<ContentEditorTypes.UpdateInfo> {\n    throw new Error('not implemented')\n  }\n\n  contentEditorMoveTextBlockCursor(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _textBlockId: string,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _movement: string,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _selectText: boolean,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _externalControlState: ContentEditorTypes.ExternalControlState,\n  ): Promise<ContentEditorTypes.UpdateInfo> {\n    throw new Error('not implemented')\n  }\n\n  contentEditorInsertTextBlockString(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _textBlockId: string,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _cluster: number | null,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _text: string,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _externalControlState: ContentEditorTypes.ExternalControlState,\n  ): Promise<ContentEditorTypes.UpdateInfo> {\n    throw new Error('not implemented')\n  }\n\n  contentEditorDeleteTextBlockRange(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _textBlockId: string,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _range: ContentEditorTypes.DirectedRange,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _externalControlState: ContentEditorTypes.ExternalControlState,\n  ): Promise<ContentEditorTypes.UpdateInfo> {\n    throw new Error('not implemented')\n  }\n\n  contentEditorLayoutTextBlock(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _textBlockId: string,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _cursor: number | null,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _selection: ContentEditorTypes.DirectedRange | null,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _externalControlState: ContentEditorTypes.ExternalControlState,\n  ): Promise<ContentEditorTypes.UpdateInfo> {\n    throw new Error('not implemented')\n  }\n\n  async contentEditorDeleteTextBlockString(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _textBlockId: string,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _direction: ContentEditorTypes.DeletionDirection,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _externalControlState: ContentEditorTypes.ExternalControlState,\n  ): Promise<ContentEditorTypes.UpdateInfo> {\n    throw new Error('not implemented')\n  }\n\n  contentEditorSetTextBlockSelection(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _textBlockId: string,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mode: ContentEditorTypes.SetSelectionMode,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _externalControlState: ContentEditorTypes.ExternalControlState,\n  ): Promise<ContentEditorTypes.UpdateInfo> {\n    throw new Error('not implemented')\n  }\n\n  contentEditorSetTextBlockSelectionRange(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _textBlockId: string,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _begin: ContentEditorTypes.Vec2,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _end: ContentEditorTypes.Vec2,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _mode: ContentEditorTypes.SetSelectionRangeMode,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _externalControlState: ContentEditorTypes.ExternalControlState,\n  ): Promise<ContentEditorTypes.UpdateInfo> {\n    throw new Error('not implemented')\n  }\n\n  async contentEditorTextBlockUndo(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _textBlockId: string,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _externalControlState: ContentEditorTypes.ExternalControlState,\n  ): Promise<ContentEditorTypes.UpdateInfo> {\n    throw new Error('not implemented')\n  }\n\n  async contentEditorTextBlockRedo(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _textBlockId: string,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _externalControlState: ContentEditorTypes.ExternalControlState,\n  ): Promise<ContentEditorTypes.UpdateInfo> {\n    throw new Error('not implemented')\n  }\n\n  async contentEditorTextBlockRestore(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _textBlockId: string,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _version: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _externalControlState: ContentEditorTypes.ExternalControlState,\n  ): Promise<ContentEditorTypes.UpdateInfo> {\n    throw new Error('not implemented')\n  }\n\n  async contentEditorTextBlockApplyFormat(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _textBlockId: string,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _range: ContentEditorTypes.DirectedRange | null,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _formatModifications: ContentEditorTypes.FormatModifications,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _externalControlState: ContentEditorTypes.ExternalControlState,\n  ): Promise<ContentEditorTypes.UpdateInfo> {\n    throw new Error('not implemented')\n  }\n\n  async contentEditorSave(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _textBlockSaveInfos: ContentEditorTypes.TextBlockSaveInfo[],\n  ): Promise<ArrayBuffer> {\n    throw new Error('not implemented')\n  }\n\n  async contentEditorGetAvailableFaces(): Promise<ContentEditorTypes.AvailableFace[]> {\n    throw new Error('not implemented')\n  }\n\n  async contentEditorSaveAndReload(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _textBlockSaveInfos: ContentEditorTypes.TextBlockSaveInfo[],\n  ): Promise<LoadResponse> {\n    throw new Error('not implemented')\n  }\n}\n\nfunction parseAsJSONOrString(response: Response) {\n  // The response stream needs to be cloned before attempting\n  // to read from it again (in case we need to fallback to text\n  // parsing)\n  return response\n    .clone()\n    .json()\n    .catch(() => response.text())\n}\n\nasync function createOperationsPayload(operations) {\n  const operationsDocuments = {}\n  // If multiple operations use the same blob, we only want to send it once.\n  // We track blobs that have already been appended in a WeakMap(blob => index)\n  const blobWeakMap = new WeakMap()\n  const processedOperations = await Promise.all(\n    operations.map(async (operation, index): Promise<DocumentOperationJSON> => {\n      if (operation.type === 'importDocument') {\n        const document = operation.document\n\n        invariant(\n          document instanceof File || document instanceof Blob,\n          'Wrong `importDocument` operation `document` value: it must be a File or a Blob',\n        )\n\n        return addBlobToWeakMap(\n          blobWeakMap,\n          operationsDocuments,\n          document,\n          operation,\n          index,\n          'document',\n        )\n      } else if (operation.type === 'applyInstantJson') {\n        const value = operation.instantJson\n\n        invariant(\n          typeof value === 'object' && value !== null,\n          'Wrong `applyInstantJson` operation `instantJson` value: it must be an object',\n        )\n\n        const string = JSON.stringify(value)\n        const document = new Blob([string], {\n          type: 'application/json',\n        })\n\n        return addBlobToWeakMap(\n          blobWeakMap,\n          operationsDocuments,\n          document,\n          operation,\n          index,\n          'dataFilePath',\n        )\n      } else if (operation.type === 'applyXfdf') {\n        const value = operation.xfdf\n\n        invariant(\n          typeof value === 'string',\n          'Wrong `applyXfdf` operation `xfdf` value: it must be a string',\n        )\n\n        const document = new Blob([value], {\n          type: 'application/vnd.adobe.xfdf',\n        })\n\n        return addBlobToWeakMap(\n          blobWeakMap,\n          operationsDocuments,\n          document,\n          operation,\n          index,\n          'dataFilePath',\n        )\n      }\n\n      return operation\n    }),\n  )\n  const formData = new FormData()\n\n  formData.append(\n    'operations',\n    JSON.stringify({\n      operations: processedOperations,\n    }),\n  )\n\n  for (const document in operationsDocuments) {\n    formData.append(document, operationsDocuments[document])\n  }\n\n  return formData\n}\n\nfunction validateInstantSetting(instant: boolean | InstantSettings) {\n  let error = ''\n\n  // Validate instant property.\n  if (typeof instant !== 'boolean') {\n    if (isPlainObject(instant)) {\n      if (\n        instant.hasOwnProperty('clientsPresenceEnabled') &&\n        typeof instant['clientsPresenceEnabled'] !== 'boolean'\n      ) {\n        error +=\n          '`clientsPresenceEnabled` in instance settings is not valid. Must be `true` or `false`.\\n'\n      }\n\n      if (\n        instant.hasOwnProperty('listenToServerChangesEnabled') &&\n        typeof instant['listenToServerChangesEnabled'] !== 'boolean'\n      ) {\n        error +=\n          '`listenToServerChangesEnabled` in instance settings is not valid. Must be `true` or `false`.\\n'\n      }\n    } else {\n      error = '`instant` flag must either be set to `true` or `false`\\n'\n    }\n\n    if (error) {\n      throw new PSPDFKitError(`${error}\nFor more information about PSPDFKit Instant please visit:\nhttps://pspdfkit.com/guides/web/current/instant/overview/`)\n    }\n  }\n}\n\nfunction resolveServerUrl(configuration: ServerConfiguration, _window: Window = window): string {\n  const serverUrl = configuration.serverUrl || getBaseUrl(_window.document)\n\n  // serverUrl must have a slash at the end\n  if (serverUrl.substr(-1) !== '/') {\n    throw new PSPDFKitError(\n      '`serverUrl` must have a slash at the end (e.g. `https://pspdfkit.example.com/`).',\n    )\n  }\n\n  // Verify that the base URL is different from the current browser's location. If it's the same,\n  // we assume that we haven't loaded PSPDFKit for Web from the Server origin and bail out. If\n  // the `serverUrl` is explicitly set in the configuration, we will always use it\n  if (!configuration.serverUrl) {\n    // There were some problems with `window.location.origin` in IE11 on Win10 [1], that's why\n    // we use `window.location.host` instead.\n    // [1]: https://goo.gl/5D5mNX\n    const browserOrigin = `${_window.location.protocol}//${_window.location.host}/`\n\n    if (serverUrl === browserOrigin) {\n      throw new PSPDFKitError(`PSPDFKit automatically infers the URL of PSPDFKit Server from the current \\`<script>\\` tag.\nIn the current case, this URL is set to the same as the current browser's location.\nThis can happen when you bundle pspdfkit.js with your custom JavaScript for example.\n\nTo make sure everything works as expected, please set the \\`serverUrl\\` to the URL of PSPDFKit Server:\n\nPSPDFKit.load({\n  serverUrl: \"https://pspdfkit-server.example.com/\",\n  ...,\n});`)\n    }\n  }\n\n  return serverUrl\n}\n","import { PSPDFKitError } from '@pspdfkit/shared'\nimport { invariant } from '@pspdfkit/shared'\nimport { Base64 } from 'js-base64'\n\n/**\n * This function can be used to validate a JWT. Will throw a PSPDFKitError if\n * the token is invalid.\n * Can also be used to log deprecation warnings.\n */\nexport function validateJWT(jwt: string): void {\n  const JWT_INVALID = `The supplied JWT is invalid. Please refer to our guides on how to set up authentication:\n  https://pspdfkit.com/guides/web/current/server-backed/client-authentication/`\n  const DOCUMENT_ID_NOT_STRING = `The supplied JWT is invalid. The field 'document_id' has to be a string value.\n  Please refer to our guides for further information: https://pspdfkit.com/guides/web/current/server-backed/client-authentication/`\n\n  // Our dashboard uses internal API to authenticate the request. In this case,\n  // the `jwt` is not a valid JWT but another JSON.\n  // We will bypass the validation in this case.\n  if (jwt.indexOf('{\"internal\":') !== -1) {\n    return\n  }\n\n  // We require a JWT to be a string with two dots\n  invariant(typeof jwt === 'string' && jwt.split('.').length === 3, JWT_INVALID)\n\n  // We parse the user data section of the JWT.\n  let userContent\n\n  try {\n    const json = Base64.decode(jwt.split('.')[1])\n\n    userContent = JSON.parse(json)\n  } catch (e) {\n    throw new PSPDFKitError(JWT_INVALID)\n  }\n\n  invariant(typeof userContent.document_id === 'string', DOCUMENT_ID_NOT_STRING)\n}\n\nexport function validateDocumentAccessToken(accessToken: string): void {\n  // noinspection SuspiciousTypeOfGuard\n  if (typeof accessToken !== 'string') {\n    throw new PSPDFKitError('`accessToken` must be of type string.')\n  }\n}\n","import { PSPDFKitError } from '@pspdfkit/shared'\nimport { getVersionHeader } from '@/utils/environment'\nimport { ILicenseFeature } from '@/enums/LicenseFeature'\n\nimport type { SignaturesInfoJSON } from '@/core/CoreTypes'\nimport type { ISignatureFeatureAvailability } from '@/enums/SignatureFeatureAvailability'\n\nexport type AuthResponse = {\n  imageToken: string\n  token: string\n  permissions: Array<string>\n  features: Array<ILicenseFeature>\n  signatureFeatureAvailability: ISignatureFeatureAvailability\n  hasPassword: boolean\n  minSearchQueryLength: number\n  layerHandle: string\n  allowedTileScales: 'all' | Array<number>\n  digitalSignatures: SignaturesInfoJSON\n  defaultGroup: string | undefined\n  creatorName: string | undefined\n  collaborationPermissions?: Record<string, any>\n}\n\n/**\n * Calls the `/auth` endpoint and generates the tokens.\n */\nexport async function authenticate(\n  documentURL: string,\n  authPayload: {\n    jwt: string\n  },\n  password?: string | null,\n): Promise<AuthResponse> {\n  const res = await fetch(`${documentURL}/auth`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'PSPDFKit-Platform': 'web',\n      'PSPDFKit-Version': getVersionHeader(),\n    },\n    body: JSON.stringify({\n      jwt: authPayload.jwt,\n      // IE11 does not send `Origin` headers for some requests, since it has a different\n      // understanding of the origin spec. To still be able to verify the origin in the IE11 case,\n      // we add that information as payload manually.\n      // There were some problems with `window.location.origin` in IE11 on Win10 [1], that's why\n      // we use `window.location.href` instead.\n      // [1]: https://goo.gl/5D5mNX\n      origin: window.location.href,\n      password: password,\n    }),\n    credentials: 'include',\n  })\n\n  if (res.ok) {\n    return res.json()\n  } else {\n    return res.text().then(message => {\n      if (message === 'INVALID_PASSWORD') {\n        throw new PSPDFKitError(message)\n      } else {\n        throw new PSPDFKitError(\n          `An error occurred while connecting to PSPDFKit Server: ${message || res.statusText}`,\n        )\n      }\n    })\n  }\n}\n","export type HostedDocumentAuthResponse = {\n  jwt: string\n  serverId: string\n  serverUrl: string\n}\n\n/**\n * Calls the `/auth` endpoint of the Hosted API.\n */\nexport async function authenticateHostedDocument(\n  hostedBaseUrl: string,\n  accessToken: string,\n): Promise<HostedDocumentAuthResponse> {\n  const res = await fetch(`${hostedBaseUrl}i/documents/auth`, {\n    method: 'POST',\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n      'PSPDFKit-Platform': 'web',\n      'PSPDFKit-Version': `cloud-protocol=${PSPDFKIT_DEFINES.HOSTED_CLOUD_PROTOCOL}, server-protocol=${PSPDFKIT_DEFINES.SERVER_PROTOCOL}, client=${PSPDFKIT_DEFINES.VERSION}, client-git=${PSPDFKIT_DEFINES.REVISION}`,\n    },\n    body: JSON.stringify({\n      accessToken,\n    }),\n  })\n\n  if (res.ok) {\n    return res.json()\n  } else {\n    throw new Error(`An error occurred while connecting to PSPDFKit API: ${await res.text()}`)\n  }\n}\n","import { Map } from 'immutable'\nimport { Annotation, WidgetAnnotation, FormFieldValue, SignatureFormField } from '../models'\nimport { invariant } from '@pspdfkit/shared'\nimport { isCacheableAnnotationAPStream } from '@/utils/annotation'\n\nimport type { AnnotationVariant, ID } from '@/models/annotations/Annotation'\nimport type { Set } from 'immutable'\nimport type ImageHandle from '../lib/handles/ImageHandle'\nimport type { Backend } from '@/typings/backend'\nimport type { IFunction } from '@/typings/utils'\n\n/**\n * SharedBackend\n *\n * This class contains code that can be reused by both StandaloneBackend and SharedBackend, which extend it.\n *\n * Methods and instance variables that are identical in both backends can be moved here so as to reduce\n * the amount of moving parts and therefore the chance for errors.\n */\nexport class SharedBackend {\n  cachedAPStreams: Map<number, Map<ID, ImageHandle<HTMLImageElement>>> = Map()\n  pageAPStreamsPromises: Map<number, Promise<void>> = Map()\n  annotationAPStreamPromises: Map<\n    ID,\n    (arg0: ImageHandle<HTMLImageElement | HTMLCanvasElement> | null | undefined) => void\n  > = Map()\n\n  /**\n   * Processes a renderAnnotation request with the following rules:\n   *\n   * - If the annotation AP stream is non-cacheable, it calls renderAnnotation() right away.\n   * - If the annotation AP stream is cacheable, it waits for the page AP streams to be available if needed.\n   * - If the AP stream is available it resolves with it. Otherwise, it calls renderAnnotation().\n   */\n  cachedRenderAnnotation(\n    annotation: Annotation,\n    blob: Blob | null | undefined,\n    width: number,\n    height: number,\n    variant?: AnnotationVariant,\n  ): {\n    promise: Promise<ImageHandle<HTMLImageElement | HTMLCanvasElement> | null | undefined>\n    cancel: IFunction\n  } {\n    const provider = (this as any as Backend).provider\n\n    invariant(\n      provider instanceof provider.constructor,\n      'Backend can only use backend annotation provider',\n    )\n\n    // For widget annotations, we need the associated form field to render the widget with the current value.\n    const formField =\n      annotation instanceof WidgetAnnotation\n        ? provider._readStateCallbacks?.getFormFieldByName(annotation.formFieldName)\n        : null\n    const formFieldValue =\n      formField && !(formField instanceof SignatureFormField)\n        ? new FormFieldValue({\n            name: formField.name,\n            // We will not be running JS when rendering the widget, so we pass the\n            // formatted value if available.\n            value:\n              typeof formField.formattedValue !== 'undefined'\n                ? formField.formattedValue\n                : typeof formField.value === 'string'\n                ? formField.value\n                : formField.values,\n          })\n        : null\n\n    // images, stamps, unknown annotation types and signature widgets AP streams are not cached in the backend instance.\n    if (!isCacheableAnnotationAPStream(annotation, formField)) {\n      return (this as unknown as Backend).renderAnnotation(\n        annotation,\n        formFieldValue,\n        blob,\n        width,\n        height,\n        variant,\n      )\n    }\n\n    let cancelled = false\n\n    let cancelPromise = () => {\n      cancelled = true\n    }\n\n    return {\n      // eslint-disable-next-line no-async-promise-executor\n      promise: new Promise(async (resolve, reject) => {\n        const cleanResolve = imageHandle => {\n          // Instead of just resolving with the image handle, we first delete the registered\n          // resolve callback from the backend promise resolve map.\n          const annotationAPStreamPromiseResolve = this.annotationAPStreamPromises.get(\n            annotation.id,\n          )\n\n          if (annotationAPStreamPromiseResolve) {\n            this.annotationAPStreamPromises = this.annotationAPStreamPromises.delete(annotation.id)\n            annotationAPStreamPromiseResolve(imageHandle)\n          }\n        }\n\n        // Check if a previous renderAnnotation() request is waiting.\n        const annotationAPStreamPromiseResolve = this.annotationAPStreamPromises.get(annotation.id)\n\n        // Register the new resolve callback.\n        this.annotationAPStreamPromises = this.annotationAPStreamPromises.set(\n          annotation.id,\n          resolve,\n        )\n\n        // Resolve any previous request with null to prevent the calling image component from stalling.\n        if (annotationAPStreamPromiseResolve) {\n          annotationAPStreamPromiseResolve(null)\n        }\n\n        try {\n          // Retrieve the current page's AP streams render promise.\n          const pageAPStreamsPromise = this.pageAPStreamsPromises.get(annotation.pageIndex)\n\n          if (!pageAPStreamsPromise) {\n            // If the promise is not available, it means that renderPageAnnotations() has not been called yet\n            // for this page. Therefore we register the resolve callback so it gets called when renderPageAnnotations()\n            // is called and resolves.\n            const annotationAPStreamPromise = new Promise(resolve => {\n              this.annotationAPStreamPromises = this.annotationAPStreamPromises.set(\n                annotation.id,\n                resolve,\n              )\n            })\n\n            // Wait for the registered resolve callback to be called.\n            const imageHandle = (await annotationAPStreamPromise) as ImageHandle<HTMLImageElement>\n\n            resolve(imageHandle)\n\n            return\n          } else {\n            // Wait for the page AP streams to be available.\n            await pageAPStreamsPromise\n          }\n\n          const cachedPageAPStreams = this.cachedAPStreams.get(annotation.pageIndex)\n\n          // Are there already cached AP streams for this page?\n          if (cachedPageAPStreams && !variant) {\n            // Is there already a cached AP stream for the annotation?\n            const cachedAPStream = cachedPageAPStreams\n              ? cachedPageAPStreams.get(annotation.id)\n              : null\n\n            if (cachedAPStream) {\n              // Then resolve with the cached AP stream\n              cleanResolve(cachedAPStream)\n\n              return\n            }\n          }\n\n          // In any other case, render the annotation.\n          const { promise, cancel } = (this as unknown as Backend).renderAnnotation(\n            annotation,\n            formFieldValue,\n            blob,\n            width,\n            height,\n            variant,\n          )\n\n          if (cancelled) {\n            cleanResolve(null)\n          } else {\n            cancelPromise = cancel\n\n            const imageHandle = await promise\n\n            cleanResolve(imageHandle)\n            imageHandle && !variant && this.cacheAPStream(imageHandle, annotation)\n          }\n        } catch (e) {\n          reject(e)\n        }\n      }),\n      cancel: cancelPromise,\n    }\n  }\n\n  // Stores the provided imageHandle for caching under the pageIndex, annotation.id key\n  cacheAPStream(\n    imageHandle: ImageHandle<HTMLImageElement | HTMLCanvasElement>,\n    annotation: Annotation,\n  ) {\n    let cachedPageAPStreams = this.cachedAPStreams.get(annotation.pageIndex)\n\n    if (!cachedPageAPStreams) {\n      this.cachedAPStreams = this.cachedAPStreams.set(annotation.pageIndex, Map())\n      cachedPageAPStreams = this.cachedAPStreams.get(annotation.pageIndex)\n    }\n\n    invariant(cachedPageAPStreams)\n\n    this.cachedAPStreams = this.cachedAPStreams.setIn(\n      [annotation.pageIndex, annotation.id],\n      imageHandle,\n    )\n  }\n\n  // Releases and removes all AP streams cached for a given page.\n  // Called when AnnotationLayerComponent unmounts.\n  clearAllPageAPStreams(pageIndex: number) {\n    const cachedPageAPStreams = this.cachedAPStreams.get(pageIndex)\n\n    if (cachedPageAPStreams) {\n      cachedPageAPStreams.forEach(APStream => {\n        APStream.release()\n      })\n      this.cachedAPStreams = this.cachedAPStreams.delete(pageIndex)\n    }\n\n    this.pageAPStreamsPromises = this.pageAPStreamsPromises.delete(pageIndex)\n  }\n\n  // Releases and removes the specified AP streams cached for a given page.\n  // Called when an annotation's AP stream is invalidated.\n  clearPageAPStreams(pageIndex: number, annotationIds: Set<ID>) {\n    const cachedPageAPStreams = this.cachedAPStreams.get(pageIndex)\n\n    if (cachedPageAPStreams) {\n      cachedPageAPStreams\n        .filter((_APStream, annotationId) => annotationIds.has(annotationId))\n        .forEach(APStream => {\n          APStream.release()\n        })\n      this.cachedAPStreams = this.cachedAPStreams.updateIn([pageIndex], cachedPageAPStreams =>\n        cachedPageAPStreams.filter((_APStream, annotationId) => !annotationIds.has(annotationId)),\n      )\n    }\n  }\n}\n","import { OrderedMap, Map, set } from 'immutable'\nimport { Request } from './types/Request'\nimport { invariant } from '../../utils/invariant'\n\ntype PromiseTuple = {\n  promise: Promise<any>\n  resolve: (arg0: any) => unknown\n  reject: (arg0: any) => unknown\n}\n\nfunction functionThatReturnsTrue() {\n  return true\n}\n/**\n * The request queue is used by all backends in order to throttle concurrent\n * requests to common resources and to have a mechanism for the UI to declare\n * resources as unnecessary so that we avoid expensive computation/IO time.\n *\n * Resources can be enqueued with normal and high priority. The queue will\n * process resources that have a high priority before normal priority resources\n * (starvation, the issue that high priority work cause low priority work to\n * never run, is not handled). A maximum number of inflight requests can be\n * configured to limit concurrent requests.\n *\n * Inflight requests are not cancelled when the cancel callback is called. They\n * are just flagged as \"cancelled\" and their responses are ignored (we noop).\n * Cancellation only affects queued requests which are then removed from the\n * queue.\n */\n\nexport default class RequestQueue {\n  queue: OrderedMap<Request, PromiseTuple>\n  priorityQueue: OrderedMap<Request, PromiseTuple>\n  inFlightRequests: Map<Request, PromiseTuple>\n  inflightRequestLimit: number\n  isDestroyed: boolean\n\n  constructor(inflightRequestLimit: number) {\n    this.queue = OrderedMap()\n    this.priorityQueue = OrderedMap()\n    this.inFlightRequests = Map()\n    this.inflightRequestLimit = inflightRequestLimit\n    this.isDestroyed = false\n  }\n\n  /**\n   * Enqueues the given `request` and returns a promise, which resolves with the\n   * response from the request. It's important to save the returned promise and\n   * not call `.then` on it, otherwise you would get a new promise back, since\n   * Promises are immutable.\n   *\n   * Enqueuing a request doesn't mean that your given request got resolved, but\n   * you're listening now on the given response of this request.\n   *\n   * @example\n   * const { promise, cancel } = requestQueue.enqueue(request)\n   * promise.then(function (response) {\n   *  // you code goes here\n   * })\n   */\n  enqueue(\n    request: Request,\n    hasPriority = false,\n  ): {\n    promise: Promise<any>\n    cancel: () => void\n  } {\n    if (this.isDestroyed) {\n      return {\n        promise: new Promise(() => {}),\n        cancel: () => {},\n      }\n    }\n\n    const cancel = () => {\n      return this._cancel(request)\n    }\n\n    // We need the any cast here as flow does not know that the resolve and\n    // reject functions are initialized synchronously.\n    let resolve: any = null\n    let reject: any = null\n    const promise = new Promise((resolveFn, rejectFn) => {\n      resolve = resolveFn\n      reject = rejectFn\n    })\n    const targetQueue: OrderedMap<Request, PromiseTuple> = hasPriority\n      ? this.priorityQueue\n      : this.queue\n    const newQueue = set(targetQueue, request, {\n      promise,\n      resolve,\n      reject,\n    } as PromiseTuple)\n\n    if (hasPriority) {\n      this.priorityQueue = newQueue\n    } else {\n      this.queue = newQueue\n    }\n\n    if (hasPriority) {\n      // We can resolve the new requests immediately\n      this.next()\n    } else {\n      // Resolve the new request asynchronously so that other requests with\n      // `hasPriority: true` fires first.\n      setTimeout(() => this.next(), 35)\n    }\n\n    return {\n      promise,\n      cancel,\n    }\n  }\n\n  _cancel(request: Request): void {\n    if (this.queue.has(request)) {\n      this.queue = this.queue.delete(request)\n    }\n\n    if (this.priorityQueue.has(request)) {\n      this.priorityQueue = this.priorityQueue.delete(request)\n    }\n\n    if (this.inFlightRequests.has(request)) {\n      this.inFlightRequests = this.inFlightRequests.delete(request)\n    }\n  }\n\n  /**\n   * Cancels all the requests and removes all the promises\n   */\n  cancelAll(): void {\n    this.queue = OrderedMap()\n    this.priorityQueue = OrderedMap()\n    this.inFlightRequests = Map()\n  }\n\n  /**\n   * Resolves and then removes the queued request, identified by the given\n   * `url`. Also starts the next request in the queue\n   */\n  _requestFinished(request: Request, response: any): void {\n    if (this.isDestroyed) {\n      return\n    }\n\n    const promiseTuple = this.inFlightRequests.get(request)\n\n    if (promiseTuple) {\n      promiseTuple.resolve(response)\n      this.inFlightRequests = this.inFlightRequests.delete(request)\n    }\n\n    this.next()\n  }\n\n  /**\n   * Rejects promise with given error and queues next request\n   */\n  _requestFailed(request: Request, error: Error) {\n    if (this.isDestroyed) {\n      return\n    }\n\n    const promiseTuple = this.inFlightRequests.get(request)\n\n    if (promiseTuple) {\n      promiseTuple.reject(error)\n      this.inFlightRequests = this.inFlightRequests.delete(request)\n    }\n\n    this.next()\n  }\n\n  /**\n   * Queues next request\n   */\n  next() {\n    if (this.isDestroyed) {\n      return\n    }\n\n    if (this.inFlightRequests.size >= this.inflightRequestLimit) {\n      return\n    }\n\n    if (this.priorityQueue.size >= 1) {\n      // Use LIFO, because we want to see the overviews that get loaded last\n      // first (because often these are the tiles that came into the viewport).\n      const lastEntry: void | [Request, PromiseTuple] =\n        this.priorityQueue.findLastEntry(functionThatReturnsTrue)\n\n      invariant(lastEntry)\n\n      const [request, promiseTuple] = lastEntry\n\n      this.priorityQueue = this.priorityQueue.delete(request)\n      this.inFlightRequests = this.inFlightRequests.set(request, promiseTuple)\n      request\n        .request()\n        .then(response => this._requestFinished(request, response))\n        .catch(error => this._requestFailed(request, error))\n\n      return\n    }\n\n    if (this.queue.size >= 1) {\n      const lastEntry: void | [Request, PromiseTuple] =\n        this.queue.findEntry(functionThatReturnsTrue)\n\n      invariant(lastEntry)\n\n      const [request, promiseTuple] = lastEntry\n\n      this.queue = this.queue.delete(request)\n      this.inFlightRequests = this.inFlightRequests.set(request, promiseTuple)\n      request\n        .request()\n        .then(response => this._requestFinished(request, response))\n        .catch(error => this._requestFailed(request, error))\n\n      return\n    }\n  }\n\n  destroy() {\n    this.isDestroyed = true\n  }\n}\n","import * as Immutable from 'immutable'\nimport { ID } from '@/models/annotations/Annotation'\n\nexport interface IEmbeddedFile {\n  id: ID\n  attachmentId: string\n  description: null | string\n  fileName: null | string\n  fileSize: null | number\n  updatedAt: null | Date\n}\n\n/**\n * @classdesc\n * This record is used to persist the information for an embedded file.\n * @public\n * @memberof PSPDFKit\n * @summary Embedded File.\n * @class EmbeddedFile\n * @noconstructor\n * @extends Immutable.Record\n * @seealso PSPDFKit.Instance#getEmbeddedFiles\n * @seealso PSPDFKit.Instance#getAttachment\n */\n\nexport class EmbeddedFile extends Immutable.Record<IEmbeddedFile>({\n  id: '',\n\n  /**\n   * A unique identifier that can be used to fetch the contents of the file.\n   *\n   * ```js\n   * const embeddedFiles = await instance.getEmbeddedFiles()\n   *\n   * const file = await instance.getAttachment(embeddedFiles.get(0).attachmentId)\n   * ```\n   *\n   * @public\n   * @instance\n   * @member {string} attachmentId\n   * @memberof PSPDFKit.EmbeddedFile\n   */\n  attachmentId: '',\n\n  /**\n   * The description of the file if present.\n   *\n   * @public\n   * @instance\n   * @member {?string} description\n   * @memberof PSPDFKit.EmbeddedFile\n   * @default null\n   */\n  description: null,\n\n  /**\n   * The name of the file with extension.\n   *\n   * @public\n   * @instance\n   * @member {?string} fileName\n   * @memberof PSPDFKit.EmbeddedFile\n   * @default null\n   */\n  fileName: null,\n\n  /**\n   * Size of the file in bytes.\n   *\n   * @public\n   * @instance\n   * @member {?number} fileSize\n   * @memberof PSPDFKit.EmbeddedFile\n   * @default null\n   */\n  fileSize: null,\n\n  /**\n   * The date on which the embedded file was updated.\n   *\n   * @public\n   * @instance\n   * @member {?Date} updatedAt\n   * @memberof PSPDFKit.EmbeddedFile\n   * @default null\n   */\n  updatedAt: null,\n}) {}\n","import { ID } from '@/models/annotations/Annotation'\nimport { EmbeddedFile } from '@/models/EmbeddedFile'\nimport { generateInstantId } from '@/models/InstantID'\n\ninterface ISerialisedEmbeddedFileServer {\n  contentType: string\n  description: string\n  fileAttachmentId: string\n  fileName: string\n  fileSize: number\n  type: string\n  updatedAt: string\n  v: number\n}\n\ninterface ISerialisedEmbeddedFileStandalone {\n  fileName?: string\n  fileDescription?: string\n  modificationDate?: string\n  fileSize?: number\n}\n\nfunction isStandalone(\n  _content: ISerialisedEmbeddedFileServer | ISerialisedEmbeddedFileStandalone,\n  standalone: boolean,\n): _content is ISerialisedEmbeddedFileStandalone {\n  return standalone\n}\n\nexport function fromJSON(\n  id: ID,\n  content: ISerialisedEmbeddedFileServer | ISerialisedEmbeddedFileStandalone,\n  standalone = false,\n): EmbeddedFile {\n  if (isStandalone(content, standalone)) {\n    return new EmbeddedFile({\n      id: generateInstantId(),\n      description: content.fileDescription,\n      attachmentId: id,\n      fileName: content.fileName || null,\n      fileSize: content.fileSize || null,\n      updatedAt: content.modificationDate ? new Date(content.modificationDate) : null,\n    })\n  }\n\n  return new EmbeddedFile({\n    id,\n    description: content.description,\n    attachmentId: content.fileAttachmentId,\n    fileName: content.fileName || null,\n    fileSize: content.fileSize || null,\n    updatedAt: new Date(content.updatedAt) || null,\n  })\n}\n","/**\n * This object contains detailed Instant settings.\n *\n * @private\n * @memberof PSPDFKit\n * @interface InstantSettings\n * @server\n * @example\n * PSPDFKit.load({\n *   instant: {\n *      clientPresenceEnabled: false,\n *      listenToServerChangesEnabled: false\n *   }\n * });\n * @seealso PSPDFKit.Configuration.instant\n */\n\n/**\n * Controls whether the client presence tracking is enabled.\n *\n * When this flag is set to `true`, a single WebSocket connection is kept open to get up to date\n * information about currently connected instance clients.\n *\n * When this flag is set to `false`, client presence tracking will be disabled. This means that\n * {@link PSPDFKit.Instance#connectedClients} will return an empty map and\n * the {@link PSPDFKit.Instance~ConnectedClientsChangeEvent} won't be triggered.\n *\n * @private\n * @instance\n * @member {boolean} clientsPresenceEnabled\n * @memberof PSPDFKit.InstantSettings\n * @default true\n */\n\n/**\n * Controls whether to listen to server changes.\n *\n * When this flag is set to `true`, changes will be pulled immediately. Single HTTP connection is\n * kept open to listen to server changes in this case.\n *\n * When this flag is set to `false`, Instant won't listen to changes made by other connected clients.\n * It's clients responsibility to call {@link PSPDFKit.Instance#syncChanges} to pull latest changes.\n *\n * @private\n * @instance\n * @member {boolean} listenToServerChangesEnabled\n * @memberof PSPDFKit.InstantSettings\n * @default true\n */\nexport type InstantSettings = {\n  clientsPresenceEnabled?: boolean\n  listenToServerChangesEnabled?: boolean\n}\n\nexport const defaultInstantSettings: InstantSettings = {\n  clientsPresenceEnabled: true,\n  listenToServerChangesEnabled: true,\n}\n","export function addBlobToWeakMap(\n  blobWeakMap: WeakMap<File | Blob, string>,\n  operationsDocuments: any,\n  blob: File | Blob,\n  operation: any,\n  index: number,\n  field: string,\n) {\n  let documentIndex\n\n  // Has this blob been already appended?\n  if (blobWeakMap.has(blob)) {\n    // Get the index of the blob\n    documentIndex = blobWeakMap.get(blob)\n  } else {\n    documentIndex = index.toString()\n    // Add the blob to the form payload\n    operationsDocuments[documentIndex] = blob\n    // Track the blob\n    blobWeakMap.set(blob, documentIndex)\n  }\n\n  return { ...operation, [field]: documentIndex }\n}\n","import { JSONToRect } from '@/lib/serializers/rect'\nimport { List } from 'immutable'\nimport { invariant } from '@pspdfkit/shared'\nimport SearchResult from '../models/search/SearchResult'\n\nexport type SearchResultJSON = {\n  pageIndex: number\n  previewText: string\n  rangeInPreview: number[]\n  rectsOnPage: number[][]\n  isAnnotation?: boolean\n  annotationRect?: [number, number, number, number]\n}\n\nexport function parseJsonSearchResults(json: Array<SearchResultJSON>): List<SearchResult> {\n  invariant(Array.isArray(json), 'Wrong `json` field')\n\n  return List(\n    json\n      .map(rawResult => {\n        invariant(typeof rawResult.pageIndex === 'number', 'Wrong `pageIndex` field')\n        invariant(typeof rawResult.previewText === 'string', 'Wrong `previewText` field')\n        invariant(Array.isArray(rawResult.rangeInPreview), 'Wrong `rangeInPreview` field')\n        invariant(Array.isArray(rawResult.rectsOnPage), 'Wrong `rectsOnPage` field')\n\n        return new SearchResult({\n          pageIndex: rawResult.pageIndex,\n          previewText: rawResult.previewText,\n          locationInPreview: rawResult.rangeInPreview[0],\n          lengthInPreview: rawResult.rangeInPreview[1],\n          rectsOnPage: List(rawResult.rectsOnPage).map(jsonRect =>\n            JSONToRect(jsonRect as [number, number, number, number]),\n          ),\n          isAnnotation: !!rawResult.isAnnotation,\n          annotationRect: rawResult.annotationRect ? JSONToRect(rawResult.annotationRect) : null,\n        })\n      })\n      .filter(Boolean),\n  )\n}\n"],"names":["ServerBackendState","Immutable","authPayload","serverUrl","hostedBaseUrl","documentId","backendPermissions","documentURL","imageToken","instantSettings","token","features","List","signatureFeatureAvailability","SignatureFeatureAvailability","isFormsEnabled","minSearchQueryLength","documentHandle","isDocumentHandleOutdated","digitalSignatures","defaultGroup","undefined","hasCollaborationPermissions","forceLegacySignaturesFeature","GENERIC_RENDER_ERROR","XHRImageRequest","constructor","identifier","url","payload","doNotRequestWebP","this","abort","httpRequest","request","Promise","resolve","reject","XMLHttpRequest","open","setRequestHeader","getVersionHeader","webp","responseType","onreadystatechange","readyState","response","type","startsWith","fileReader","FileReader","onload","event","JSON","parse","target","result","attachments_not_found","attachmentsNotFound","error","PSPDFKitError","onerror","readAsText","requestIsSuccess","status","blob","objectUrl","URL","createObjectURL","img","Image","src","decode","ImageHandle","revokeObjectURL","bind","send","ServerBackend","SharedBackend","_password","configuration","_window","window","super","accessToken","documentUrl","validateHostedBaseUrl","validateDocumentAccessToken","getBaseUrl","document","substr","location","protocol","host","resolveServerUrl","jwt","JWT_INVALID","indexOf","userContent","invariant","split","length","json","Base64","e","document_id","validateJWT","instant","isPlainObject","hasOwnProperty","validateInstantSetting","settings","clientsPresenceEnabled","listenToServerChangesEnabled","defaultInstantSettings","_requestQueue","RequestQueue","MAX_RESOURCE_REQUESTS_IN_QUEUE_SERVER","electronicSignatures","Boolean","_state","disableForms","warn","isUsingInstantProvider","hasClientsPresence","async","options","tryAuthenticateHostedViewer","permissions","hasPassword","layerHandle","allowedTileScales","collaborationPermissions","creatorName","password","res","fetch","method","headers","body","stringify","origin","href","credentials","ok","text","then","message","statusText","authenticate","includes","LicenseFeature","finalSignatureFeatureAvailability","hasWebAnnotationEditingFeature","withMutations","state","set","BackendPermissions","readOnly","downloadingAllowed","deserializeSignaturesInfo","provider","destroy","_initProvider","setDocumentHandleConflictCallback","handleDocumentHandleConflict","serverId","Accept","Error","authenticateHostedDocument","InstantProvider","auth_token","RESTProvider","_destroyProvider","documentInfo","_fetch","data","getFormJSON","v","annotations","fields","getDefaultGroup","isCollaborationPermissionsEnabled","textForPageIndex","pageIndex","pageTextRequestURL","jsonRequestPromise","_getJSONRequestHandler","enqueue","promise","jsonToTextLines","cancel","getTextFromRects","rects","rectsParam","encodeURIComponent","map","rectToJSON","toArray","JSONRequest","renderTile","pageSize","tileRect","renderForPrinting","_renderText","contentState","imageTileURL","width","height","left","top","hasPriority","MAX_WEBP_DIMENSION","resolvePromise","rejectPromise","isCanceled","hasRetried","requestPromises","requestImages","requestTile","imageRequestPromise","includeAttachmentIds","formData","FormData","append","filter","isModifiableAnnotation","serializeAnnotation","toJS","content","formFieldValues","serializeFormFieldValue","formFields","serializeFormField","signatures","forEach","id","attachment","attachments","get","push","imageRequest","tile","catch","_requestRenderAnnotation","annotation","formFieldValue","detached","renderAnnotationURL","requestQueueId","ulid","annotationJSON","requestAnnotation","imageAttachmentId","_requestRenderAnnotations","annotationsPdfObjectIds","widths","heights","renderAnnotationsURL","renderRequestJSON","pdfObjectId","index","Array","from","values","renderAnnotation","unfilteredAnnotations","scaleFactor","supportsFormDataInResponse","pageAPStreamsPromise","pageAPStreamsPromises","hasWidgets","some","WidgetAnnotation","_setReadStateCallbacksPromise","formField","_readStateCallbacks","getAnnotationWithFormField","isCacheable","isCacheableAnnotationAPStream","find","name","formFieldValueFromFormField","size","renderPageAnnotationsCall","Math","floor","boundingBox","pageAPStreamsBlobs","imageHandlePromises","imageHandleFromBlob","imageHandlePromise","imageHandle","annotationAPStreamPromiseResolve","annotationAPStreamPromises","delete","cacheAPStream","all","renderDetachedAnnotation","attachmentId","searchTerm","startPageIndex","limitPages","caseSensitive","searchInAnnotations","searchType","SearchType","params","replace","toString","parseJsonSearchResults","_pageIndex","term","annotationPreset","color","fillColor","outlineColor","rest","strategy","strategyOptions","includeAnnotations","toHex","ann","RedactionAnnotationSerializer","exportPDF","flatten","includeComments","excludeAnnotations","String","r","arrayBuffer","exportXFDF","exportInstantJSON","getPDFURL","revoke","generatePDFObjectURL","isRevoked","Blob","outline","isArray","documentOutlineFromJSON","onKeystrokeEvent","operations","createOperationsPayload","reloadDocument","load","_refreshSignaturesInfoPromise","refreshSignaturesInfo","signaturePreparationData","signingServiceData","additionalParams","signerDataSource","estimatedSize","placeholderSize","signingToken","cancelRequests","getDocumentHandle","embeddedFiles","fromJSON","cancelAll","_clients","disconnect","bodyMessage","clone","parseAsJSONOrString","reason","syncChanges","_textBlockId","_renderTextBlockParams","_externalControlState","contentEditorSetTextBlockCursor","_offset","_selectText","contentEditorMoveTextBlockCursor","_movement","contentEditorInsertTextBlockString","_cluster","_text","contentEditorDeleteTextBlockRange","_range","contentEditorLayoutTextBlock","_cursor","_selection","_direction","contentEditorSetTextBlockSelection","_mode","contentEditorSetTextBlockSelectionRange","_begin","_end","_version","_formatModifications","_textBlockSaveInfos","operationsDocuments","blobWeakMap","WeakMap","processedOperations","operation","File","addBlobToWeakMap","value","instantJson","string","xfdf","cachedAPStreams","Map","cachedRenderAnnotation","variant","getFormFieldByName","formFieldName","SignatureFormField","FormFieldValue","formattedValue","cancelled","cancelPromise","cleanResolve","annotationAPStreamPromise","cachedPageAPStreams","cachedAPStream","setIn","clearAllPageAPStreams","APStream","release","clearPageAPStreams","annotationIds","_APStream","annotationId","has","updateIn","functionThatReturnsTrue","inflightRequestLimit","queue","OrderedMap","priorityQueue","inFlightRequests","isDestroyed","resolveFn","rejectFn","targetQueue","newQueue","next","setTimeout","_cancel","_requestFinished","promiseTuple","_requestFailed","lastEntry","findLastEntry","findEntry","EmbeddedFile","description","fileName","fileSize","updatedAt","isStandalone","_content","standalone","generateInstantId","fileDescription","modificationDate","Date","fileAttachmentId","field","documentIndex","rawResult","previewText","rangeInPreview","rectsOnPage","SearchResult","locationInPreview","lengthInPreview","jsonRect","JSONToRect","isAnnotation","annotationRect"],"sourceRoot":""}