{"version":3,"file":"pspdfkit-lib/chunk-server-instant-52cce420f7e59e51.js","mappings":"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","sources":["webpack://PSPDFKit/./src/lib/ClientsPresence/models/Client.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/models/ClientsPresenceState.ts","webpack://PSPDFKit/./src/lib/Timer.ts","webpack://PSPDFKit/./src/lib/WebsocketConnection/WebsocketConnection.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/utils/clients.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/ClientsPresence.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/actions/setClientsAction.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/actions/applyClientChangesAction.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/actions/updateCurrentClientPresenceAction.ts","webpack://PSPDFKit/./src/lib/InstantProvider/RecordChangeRequest.ts","webpack://PSPDFKit/./src/lib/InstantProvider/InstantSyncState.ts","webpack://PSPDFKit/./src/lib/InstantProvider/InstantSync.ts","webpack://PSPDFKit/./src/lib/InstantProvider/collaboration-permissions.ts","webpack://PSPDFKit/./src/lib/serializers/CommentSerializer.ts","webpack://PSPDFKit/./src/lib/InstantProvider/InstantProvider.ts"],"sourcesContent":["import * as Immutable from 'immutable'\n\ninterface IClient {\n  clientId: string\n  userId: string | null\n  presenceContent: Record<string, unknown>\n}\n\nexport default class Client extends Immutable.Record<IClient>({\n  clientId: '',\n  userId: null,\n  presenceContent: {},\n}) {\n  /**\n   * Holds the client ID as a string. A unique ID is generated for every client.\n   *\n   * @member {string} clientId\n   */\n  override clientId: string\n\n  /**\n   * Holds the user ID of the client. This ID is supplied by your backend. If the value is `null`,\n   * the client does not belong to a user and thus is considered anonymous.\n   *\n   * @member {?string} userId\n   */\n  override userId: string | null\n\n  /**\n   * Holds the latest presence content a client has announced. This can be an arbitrary object.\n   *\n   * @member {Object} presenceContent\n   */\n  override presenceContent: Record<string, any>\n}\n","import { Map } from 'immutable'\nimport type Client from './Client'\nimport * as Immutable from 'immutable'\n\ninterface IClientsPresenceState {\n  /**\n   * Indication of whether the client is connected to the server or not. Can either be 'offline',\n   * 'connecting' or 'online'.\n   *\n   * @member {string} status\n   */\n  status: 'offline' | 'connecting' | 'online'\n  currentClient: null | Client\n\n  /**\n   * A list of all connect clients of every user that is currently present in the record.\n   *\n   * @member {Immutable.Map.<string, Client>} presence\n   */\n  clients: Map<string, Client>\n}\n\n/**\n * ClientsPresenceState\n *\n * Describes current state of ClientsPresence\n */\n\nexport default class ClientsPresenceState extends Immutable.Record<IClientsPresenceState>({\n  status: 'offline',\n  currentClient: null,\n  clients: Map(),\n}) {}\n","export default class Timer {\n  callback: () => void\n  timerCalc: (tries: number) => number\n  timer: NodeJS.Timeout | null\n  tries: number\n\n  constructor(callback: () => void, timerCalc: (tries: number) => number) {\n    this.callback = callback\n    this.timerCalc = timerCalc\n    this.timer = null\n    this.tries = 0\n  }\n\n  reset(): void {\n    this.tries = 0\n    this.timer && clearTimeout(this.timer)\n  }\n\n  // Cancels any previous scheduleTimeout and schedules callback\n  scheduleTimeout(): void {\n    this.timer && clearTimeout(this.timer)\n    this.timer = setTimeout(() => {\n      this.tries = this.tries + 1\n      this.callback()\n    }, this.timerCalc(this.tries + 1)) as unknown as NodeJS.Timeout\n  }\n}\n","import { getEnvironment } from '@/utils/environment'\nimport { Map } from 'immutable'\nimport EventEmitter from '../EventEmitter'\nimport { PSPDFKitError } from '@pspdfkit/shared'\nimport Timer from '../Timer'\nimport { invariant } from '@/utils/invariant'\nimport { IObject } from '@/typings/utils'\n\nconst CLIENT_VERSION = '0.0.1'\nconst PROTOCOL_VERSION = 2\nconst SOCKET_STATES = {\n  connecting: 0,\n  open: 1,\n  closing: 2,\n  closed: 3,\n}\nconst CLIENT_INFO = {\n  name: 'PSPDFKit-Web',\n}\n\nconst defaultReconnectTimerCalc = n => [1000, 2000][n - 1] || 5000\n/**\n * SYNCConnection\n *\n * Abstracts the web socket and the sync protocol. This class behaves like an event emitter, which\n * means that we can listen on any incoming message using the `.on('type', callback)` method.\n *\n * In case the connection gets interrupted, we try to reconnect in a specified time interval. The\n * next time a reconnect is successful, we will emit the `reconnect` event.\n *\n * A SYNCConnection will publish the following events:\n *   - `connect` when the connection was authenticated with the argument\n *     `{ userId: ?string, clientId: string }`. This will also be called when the connection was\n *     closed and we have successfully reconnected. In theory the same token could then be used to\n *     authenticated a different user.\n *   - `disconnect` when the connection was interrupted. Use this to show a disconnect message until\n *     we emit the `authenticated` action again.\n *   - `error` when we discover a non-recoverable error during the authentication flow. In this\n *     case, we will try to reconnect. This can happen when the auth token is invalid.\n *   - `record_changes` when the server sends the analogue info request. This will simply forward\n *     the same payload\n *   - `client_presence` when the server sends the analogue info request. This will simply forward\n *     the same payload\n *\n * @private\n */\n\nexport default class WebsocketConnection {\n  eventEmitter: EventEmitter\n  serverURL: string\n  authPayload: IObject\n  socket: WebSocket | null\n  lastRequestId: number\n  requestsWaitingForAnswers: Map<\n    number,\n    {\n      resolve: (payload: IObject) => void\n      reject: (error: Error) => void\n    }\n  >\n  reconnectTimer: Timer | null\n  clientId: string\n  userId: string | null\n\n  constructor(\n    serverURL: string,\n    authPayload: IObject,\n    {\n      reconnectTimerCalc = defaultReconnectTimerCalc,\n      enableReconnect = true,\n      events = [],\n    }: {\n      reconnectTimerCalc?: (n: number) => number\n      enableReconnect?: boolean\n      events?: Array<string>\n    } = {},\n  ) {\n    this.eventEmitter = new EventEmitter(['connect', 'disconnect', 'error'].concat(events))\n    this.serverURL = serverURL\n    this.authPayload = authPayload\n    this.socket = null\n    this.lastRequestId = 0\n    this.requestsWaitingForAnswers = Map()\n\n    if (enableReconnect) {\n      this.reconnectTimer = new Timer(() => {\n        if (this.socket) {\n          this.socket.close()\n          this.socket = null\n        }\n\n        this.connect()\n      }, reconnectTimerCalc)\n    }\n\n    this.clearAuthenticationInformation()\n  }\n\n  registerEvents(events: Array<string>): void {\n    this.eventEmitter.events.push(...events)\n  }\n\n  connect() {\n    if (this.socket) {\n      return\n    }\n\n    const socket = new WebSocket(this.serverURL)\n\n    socket.onopen = this.onOpen.bind(this)\n    socket.onmessage = this.onMessage.bind(this)\n\n    socket.onerror = () => {\n      this.socket = null\n      this.eventEmitter.emit(\n        'error',\n        `Failed to create the WebSocket connection to ${this.serverURL}. ` +\n          'Please check your firewall or proxy settings.',\n      )\n    }\n\n    this.socket = socket\n  }\n\n  /**\n   * Closes the socket permanently. This will `.reject()` all outstanding request\n   */\n  disconnect(): void {\n    if (!this.socket) {\n      return\n    }\n\n    // unbind existing closing event so we don't try to reconnect\n    this.socket.onclose = () => {}\n\n    this.socket.close()\n    this.clearAuthenticationInformation()\n    this.abortOpenRequests()\n    this.eventEmitter.emit('disconnect')\n  }\n\n  /**\n   * @returns {string} The current connection state. Either `connecting`, `open`, `closing`, or\n   *          `closed`\n   */\n  get connectionState(): 'connecting' | 'open' | 'closing' | 'closed' {\n    switch (this.socket && this.socket.readyState) {\n      case SOCKET_STATES.connecting:\n        return 'connecting'\n\n      case SOCKET_STATES.open:\n        return 'open'\n\n      case SOCKET_STATES.closing:\n        return 'closing'\n\n      default:\n        return 'closed'\n    }\n  }\n\n  /**\n   * @returns {boolean} true when the connection is authenticated\n   */\n  get isAuthenticated(): boolean {\n    return this.clientId !== ''\n  }\n\n  /**\n   * Sends data asynchronously to the server. This will generate a new request ID. Whenever the\n   * server responds, we will resolve the Promise.\n   *\n   * @param {string} action - The action you want to send\n   * @param {Object} payload - An arbitrary payload. This will be serialized as JSON\n   * @returns {Promise.<Object, PSPDFKitError>} A promise that will resolve as soon as the server responds to our request.\n   */\n  sendRequest(action: string, payload: IObject): Promise<IObject> {\n    return new Promise((resolve, reject) => {\n      if (!this.isAuthenticated || !this.socket) {\n        reject(new PSPDFKitError('Cannot send request when the connection is not authenticated'))\n\n        return\n      }\n\n      const requestId = this.nextRequestId()\n      const serializedPayload = JSON.stringify(payload)\n\n      this.requestsWaitingForAnswers = this.requestsWaitingForAnswers.set(requestId, {\n        resolve,\n        reject,\n      })\n\n      const socket: WebSocket = this.socket\n\n      socket.send(`${requestId}:${action}:${serializedPayload}`)\n    })\n  }\n\n  // `on` and `off` will be forwarded to `this.eventEmitter`\n  on(\n    action: 'connect' | 'disconnect' | 'error' | string,\n    callback: (payload: IObject) => void,\n  ): void {\n    this.eventEmitter.on(action, callback)\n  }\n\n  off(\n    action: 'connect' | 'disconnect' | 'error' | string,\n    callback: (payload: IObject) => void,\n  ): void {\n    this.eventEmitter.off(action, callback)\n  }\n\n  /**\n   * Web socket callbacks\n   */\n\n  private onOpen() {\n    const socket = this.socket\n\n    if (socket) {\n      socket.onerror = this.onError.bind(this)\n      socket.onclose = this.onClose.bind(this)\n    }\n  }\n\n  private onMessage(message: MessageEvent) {\n    const data = message.data as string\n\n    if (this.isAuthenticated) {\n      const frame = this.parseFrame(data)\n\n      // Check whether this is a notification from the server or a response to a request\n      if (frame.requestId) {\n        const requestId = frame.requestId\n\n        invariant(\n          this.requestsWaitingForAnswers.has(requestId),\n          'Received a reply with an unknown request ID.',\n        )\n\n        const request = this.requestsWaitingForAnswers.get(requestId)\n\n        invariant(request)\n\n        switch (frame.action) {\n          case 'ok':\n            request.resolve(frame.payload)\n            break\n\n          case 'error':\n            request.reject(new PSPDFKitError(frame.payload.reason || 'Unknown error'))\n            break\n\n          default:\n            invariant(false, `${frame.action} is not a valid request reply`)\n        }\n\n        this.requestsWaitingForAnswers = this.requestsWaitingForAnswers.delete(requestId)\n      } else {\n        if (this.eventEmitter.events.includes(frame.action)) {\n          this.eventEmitter.emit(frame.action, frame.payload)\n        }\n\n        this.log('incoming info message', frame)\n      }\n    } else {\n      const frame = this.parseUnauthenticatedFrame(data)\n\n      // When the request is not yet authenticated, we only handle `hello` and `authenticated`\n      // messages\n      switch (frame.action) {\n        case 'hello':\n          this.onHello(frame.payload)\n          break\n\n        case 'authenticated':\n          this.onAuthenticated(frame.payload)\n          break\n\n        case 'error':\n          this.eventEmitter.emit('error', frame.payload.reason || 'Unknown error')\n      }\n    }\n  }\n\n  /**\n   * When the connection is closed, we will send the `disconnect` event so the client can display\n   * an adequate message. This will start our regular reconnection timer.\n   */\n  private onClose(event: CloseEvent) {\n    this.clearAuthenticationInformation()\n    this.abortOpenRequests()\n    this.reconnectTimer && this.reconnectTimer.scheduleTimeout()\n    this.eventEmitter.emit('disconnect')\n    this.log('close', event)\n  }\n\n  /**\n   * We will receive an error callback when there were problems opening the web socket. This will\n   * start our regular reconnection timer.\n   */\n  private onError(error: Event) {\n    this.reconnectTimer && this.reconnectTimer.scheduleTimeout()\n    this.log('error', error)\n  }\n\n  private nextRequestId(): number {\n    // We deliberately don't care about integer overflow of the request id. We will handle this in\n    // the future by reconnecting the client\n    const nextRequestId = this.lastRequestId + 1\n\n    this.lastRequestId = nextRequestId\n\n    return nextRequestId\n  }\n\n  private onHello(payload: IObject): void {\n    const socket: WebSocket = this.socket as any\n\n    if (payload.protocol_version === PROTOCOL_VERSION) {\n      const requestPayload = {\n        protocol_version: PROTOCOL_VERSION,\n        client_version: CLIENT_VERSION,\n        client_info: CLIENT_INFO,\n        auth_payload: this.authPayload,\n      }\n\n      socket.send(`hello_web:${JSON.stringify(requestPayload)}`)\n    } else {\n      const requestPayload = {\n        reason: 'protocol_mismatch',\n        protocol_version: PROTOCOL_VERSION,\n        client_version: CLIENT_VERSION,\n        client_info: CLIENT_INFO,\n      }\n\n      socket.send(`handshake_failed:${JSON.stringify(requestPayload)}`)\n      this.eventEmitter.emit('error', 'protocol_mismatch')\n    }\n  }\n\n  private onAuthenticated(payload: IObject): void {\n    invariant(payload.client_id, '`authenticated` message has no `client_id`')\n    this.clientId = payload.client_id\n    this.userId = payload.user_id || null\n    this.eventEmitter.emit('connect', {\n      clientId: this.clientId,\n      userId: this.userId,\n    })\n  }\n\n  private log(...args: Array<any>): void {\n    if (getEnvironment() === 'development') {\n      console.log('SYNCConnection', ...args) // eslint-disable-line no-console\n    }\n  }\n\n  /**\n   * When `requestId` in the response object is null, the frame is of type `info`.\n   */\n  private parseFrame(frame: string): {\n    requestId?: number | null\n    action: string\n    payload: IObject\n  } {\n    const regex = /^(\\d+|info):([a-zA-Z-_]+):(.+)$/\n    const [, requestIdOrInfo, action, serializedPayload] = regex.exec(\n      frame.toString(),\n    ) as RegExpExecArray\n    let requestId: number | null = null\n\n    if (requestIdOrInfo !== 'info') {\n      requestId = parseInt(requestIdOrInfo)\n    }\n\n    const payload = JSON.parse(serializedPayload)\n\n    return {\n      requestId,\n      action,\n      payload,\n    }\n  }\n\n  private parseUnauthenticatedFrame(frame: string): {\n    action: string\n    payload: IObject\n  } {\n    const regex = /^(hello|authenticated|error):(.+)$/\n\n    const [, action, serializedPayload] = regex.exec(frame.toString()) as RegExpExecArray\n    const payload = JSON.parse(serializedPayload)\n\n    return {\n      action,\n      payload,\n    }\n  }\n\n  /** @private **/\n  abortOpenRequests(): void {\n    this.requestsWaitingForAnswers.forEach(request => {\n      request.reject(new PSPDFKitError('request aborted'))\n    })\n    this.requestsWaitingForAnswers = Map()\n  }\n\n  /** @private **/\n  clearAuthenticationInformation(): void {\n    this.clientId = ''\n    this.userId = null\n  }\n}\n","import { invariant } from '@pspdfkit/shared'\nimport Client from '../models/Client'\n\n/**\n * Used to map a payload entry for a client to a `Client`\n */\nexport function clientFromPayload(payload: Record<string, any>): Client {\n  invariant(typeof payload.client_id === 'string', 'The client payload must have a `client_id`')\n  invariant(typeof payload.presence === 'object', 'The client payload must have a `presence`')\n\n  return new Client({\n    clientId: payload.client_id,\n    userId: payload.user_id,\n    presenceContent: payload.presence,\n  })\n}\n","import type { Class } from '@/typings/utils'\nimport { List, Map } from 'immutable'\nimport { PSPDFKitError } from '@pspdfkit/shared'\nimport Client from './models/Client'\nimport ClientsPresenceState from './models/ClientsPresenceState'\nimport WebsocketConnection from '../WebsocketConnection/WebsocketConnection'\nimport setClientsAction from './actions/setClientsAction'\nimport applyClientChangesAction from './actions/applyClientChangesAction'\nimport updateCurrentClientPresenceAction from './actions/updateCurrentClientPresenceAction'\n\nexport default class ClientsPresence {\n  connection: WebsocketConnection\n  state: ClientsPresenceState\n  setState: (arg0: ClientsPresenceState) => void\n  connectionClass: Class<any>\n  clientUpdatesCallback: (\n    arg0: Map<string, Client>,\n    arg1: Map<string, Client>,\n    arg2: List<string>,\n  ) => void\n  shouldFireClientUpdatesCallback: boolean\n\n  /**\n   * For easier testing, we allow a custom state in the constructor.\n   */\n  constructor(\n    state: ClientsPresenceState = new ClientsPresenceState(),\n    connectionClass: Class<any> = WebsocketConnection,\n  ) {\n    this.state = state\n    this.connectionClass = connectionClass\n  }\n\n  /**\n   * This method should be called right after the constructor.\n   */\n  load(\n    serverURL: string,\n    authPayload: Record<string, any>,\n    initialPresenceContent: Record<string, any>,\n  ): Promise<ClientsPresence> {\n    return new Promise((resolve, reject) => {\n      this.setState = (newState: ClientsPresenceState): void => {\n        this.state = newState\n      }\n\n      this.connection = new this.connectionClass(serverURL, authPayload, {\n        events: ['client_presence'],\n      })\n      this.connection.on(\n        'connect',\n        // @ts-expect-error\n        (session: { clientId: string; userId?: string | null }) => {\n          const currentClient = new Client({\n            clientId: session.clientId,\n            userId: session.userId,\n            presenceContent: initialPresenceContent,\n          })\n\n          this.setState(this.state.set('status', 'online').set('currentClient', currentClient))\n          this.populateClients(initialPresenceContent)\n            .then(() => {\n              resolve(this)\n            })\n            .catch(reject)\n        },\n      )\n      this.connection.on('error', message => {\n        reject(new PSPDFKitError(message.toString()))\n      })\n      this.connection.on('client_presence', payload => this.onInfoClientPresence(payload))\n      this.connection.connect()\n    })\n  }\n\n  populateClients(presenceContent: Record<string, any>): Promise<any> {\n    return new Promise<void>((resolve, reject) => {\n      const enterZonePayload = {\n        presence: presenceContent,\n      }\n\n      this.connection\n        .sendRequest('enter_layer', enterZonePayload)\n        .then(payload => {\n          this.setState(setClientsAction(this.state, payload))\n          resolve()\n        })\n        .catch(reject)\n    })\n  }\n\n  onInfoClientPresence(payload: Record<string, any>): void {\n    this.setState(applyClientChangesAction(this.state, payload))\n\n    if (this.shouldFireClientUpdatesCallback) {\n      let entered: Map<string, Client> = Map()\n\n      if (payload.clients.entered) {\n        const enteredClientIds = payload.clients.entered.map(c => c.client_id)\n\n        entered = this.state.clients\n          .filter(client => {\n            return enteredClientIds.indexOf(client.clientId) !== -1\n          })\n          .toMap()\n      }\n\n      let updated: Map<string, Client> = Map()\n\n      if (payload.clients.updated) {\n        const updatedClientIds = payload.clients.updated.map(c => c.client_id)\n\n        updated = this.state.clients\n          .filter(client => {\n            return updatedClientIds.indexOf(client.clientId) !== -1\n          })\n          .toMap()\n      }\n\n      let left = List()\n\n      if (payload.clients.updated) {\n        left = List(payload.clients.left)\n      }\n\n      this.clientUpdatesCallback(entered, updated, left)\n    }\n  }\n\n  /**\n   * Close the current connection and stop reconnecting attempts.\n   *\n   * @returns {void}\n   */\n  disconnect(): void {\n    if (this.getStatus() === 'offline') {\n      return\n    }\n\n    this.setState(this.state.set('status', 'offline'))\n    this.connection.disconnect()\n  }\n\n  /**\n   * Indication of whether the client is connected to the server or not.\n   *\n   * @returns {string} A status indicating the connection status, either `offline`, `connecting`, or\n   *         `online`.\n   */\n  getStatus(): 'offline' | 'connecting' | 'online' {\n    return this.state.status\n  }\n\n  /**\n   * Information about the currently connected client.\n   *\n   * @returns {Client} An object that holds information about the currently connected client.\n   */\n  getCurrentClient(): Client {\n    return this.state.currentClient as Client\n  }\n\n  /*********************\n   * Managing Presence *\n   *********************/\n\n  /**\n   * Returns a map of all connected clients of every user that is currently present in the zone.\n   *\n   * Before this method is called the first time, we will never fire a\n   * {@link ClientsPresence#onClientUpdates} callback. The reason for this is to give you time to set\n   * your callbacks, without missing out on information.\n   *\n   * @returns {Immutable.Map.<string, Client>} List of all connected clients form all users\n   */\n  getClients(): Map<string, Client> {\n    this.shouldFireClientUpdatesCallback = true\n\n    return this.state.clients\n  }\n\n  /**\n   * Updates the presence content for the zone of the current connection. The presence content is\n   * being broadcast to all other connected clients.\n   *\n   * When the server accepts our changes, we will resolve the `Promise` with `true`. In case of any\n   * error, we will reject with `PSPDFKitError`.\n   *\n   * @param {object} presenceContent - An arbitrary object that describes the presence content.\n   * @returns {Promise.<boolean, PSPDFKitError>} A Promise that that will resolve with `true` or reject\n   *         with a `PSPDFKitError`.\n   */\n  updatePresence(presenceContent: Record<string, any>): Promise<boolean> {\n    return new Promise((resolve, reject) => {\n      if (this.getStatus() !== 'online') {\n        return reject(new PSPDFKitError('ClientsPresence is not connected'))\n      }\n\n      const payload = {\n        presence: presenceContent,\n      }\n\n      this.connection.sendRequest('update_client_presence', payload).then(\n        () => {\n          this.setState(updateCurrentClientPresenceAction(this.state, presenceContent))\n          resolve(true)\n        },\n        () => {\n          reject(new PSPDFKitError('Unable to update presence'))\n        },\n      )\n    })\n  }\n\n  /**********************\n   * Presence Callbacks *\n   **********************/\n\n  /**\n   * This callback will be triggered whenever the client map will be updated. It will contain\n   * the change set of entered, updated and left clients.\n   *\n   * It will not fire without you calling {@link ClientsPresence#getClients} before.\n   *\n   * @callback clientUpdatesCallback\n   * @param {Immutable.Map.<string, Client>} entered - A map of all clients that have entered\n   *        the zone\n   * @param {Immutable.Map.<string, Client>} updated - A map of all clients that published\n   *        presence updates.\n   * @param {Immutable.List.<string>} left - A list of all clients IDs that have disconnected from\n   *        this zone.\n   */\n\n  /**\n   * Sets a new clients update callback. When a callback is already set, it will overwrite the\n   * existing one (only one callback is registered to a ClientsPresence instance at any time).\n   *\n   * This callback should be registered before you call {@link ClientsPresence#getClients}. It will only\n   * fire after {@link ClientsPresence#getClients} is called the first times.\n   *\n   * The callback can never be set to `null` because otherwise your application could miss out on\n   * updates.\n   *\n   * @throws {TypeError} when the supplied `callback` is not a function\n   * @param {clientUpdatesCallback} callback - The callback that handles the clients map updates\n   */\n  onClientUpdates(\n    callback: (\n      entered: Map<string, Client>,\n      updated: Map<string, Client>,\n      left: List<string>,\n    ) => void,\n  ) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function')\n    }\n\n    this.clientUpdatesCallback = callback\n  }\n}\n","import { clientFromPayload } from '../utils/clients'\nimport { Map } from 'immutable'\nimport type ClientsPresenceState from '../models/ClientsPresenceState'\nimport { invariant } from '../../../utils/invariant'\nimport Client from '../models/Client'\n\n/**\n * This action overwrites the current clients map with the `payload`. This is used, whenever we\n * `enter_layer`\n */\n\nexport default function setClientsAction(\n  state: ClientsPresenceState,\n  payload: Record<string, any>,\n): ClientsPresenceState {\n  invariant(payload.clients, 'The payload must have a `clients` list')\n\n  return state.withMutations(mutableState => {\n    const clients = Map(\n      payload.clients\n        .map(clientPayload => clientFromPayload(clientPayload))\n        .map(c => [c.clientId, c]),\n    ).set(state.currentClient?.clientId, state.currentClient) as Map<string, Client>\n\n    mutableState.set('clients', clients)\n  })\n}\n","import { clientFromPayload } from '../utils/clients'\nimport { PSPDFKitError } from '@pspdfkit/shared'\nimport type ClientsPresenceState from '../models/ClientsPresenceState'\nimport { invariant } from '../../../utils/invariant'\n\n/**\n * This action applies the change set from the `info:client_presence` message.\n *\n * @throws {PSPDFKitError} when we detect a failed state\n */\n\nexport default function applyClientChangesAction(\n  state: ClientsPresenceState,\n  payload: Record<string, any>,\n): ClientsPresenceState {\n  invariant(typeof payload.clients == 'object', 'The payload must have `clients`')\n\n  const newClients = state.clients.withMutations(mutableClients => {\n    if (payload.clients.entered) {\n      for (const clientPayload of payload.clients.entered) {\n        if (state.clients.has(clientPayload.client_id)) {\n          throw new PSPDFKitError('The client marked as entered is already known')\n        }\n\n        const client = clientFromPayload(clientPayload)\n\n        mutableClients.set(client.clientId, client)\n      }\n    }\n\n    // On updated clients, only the `presenceContent` can change\n    if (payload.clients.updated) {\n      for (const clientPayload of payload.clients.updated) {\n        invariant(\n          typeof clientPayload.client_id === 'string',\n          'The client payload must have a `client_id`',\n        )\n        invariant(\n          typeof clientPayload.presence === 'object',\n          'The client payload must have a `presence`',\n        )\n\n        const client = state.clients.get(clientPayload.client_id)\n\n        if (!client) {\n          throw new PSPDFKitError('The client marked as updated is not known')\n        }\n\n        mutableClients.set(client.clientId, client.set('presenceContent', clientPayload.presence))\n      }\n    }\n\n    if (payload.clients.left) {\n      for (const clientId of payload.clients.left) {\n        if (!state.clients.has(clientId)) {\n          throw new PSPDFKitError('The client marked as left is not known')\n        }\n\n        mutableClients.delete(clientId)\n      }\n    }\n  })\n\n  return state.set('clients', newClients)\n}\n","import type ClientsPresenceState from '../models/ClientsPresenceState'\n/**\n * This is used after a successful `update_client_presence` and will set the new `presenceContent`\n * inside the `currentClient` and the current client inside the `clients` map.\n */\n\nexport default function updateCurrentClientPresenceAction(\n  state: ClientsPresenceState,\n  presenceContent: Record<string, any>,\n): ClientsPresenceState {\n  return state\n    .setIn(['currentClient', 'presenceContent'], presenceContent)\n    .setIn(['clients', state.currentClient?.clientId, 'presenceContent'], presenceContent)\n}\n","import * as Immutable from 'immutable'\nimport { ServerRecordsContent } from '@/typings/backend'\n\ninterface IRecordChangeRequest {\n  id: string | null\n  content?: ServerRecordsContent | null\n  attachments: Record<string, Blob> | null\n  group?: string | null\n  isAnonymous?: boolean\n  type: 'created' | 'updated' | 'deleted' | null\n  resolve: (value?: void) => void\n  reject: (error?: Error) => void\n}\n\nexport default class RecordChangeRequest extends Immutable.Record<IRecordChangeRequest>({\n  content: null,\n  attachments: null,\n  id: null,\n  type: null,\n  isAnonymous: undefined,\n  group: undefined,\n  resolve: () => {},\n  reject: () => {},\n}) {\n  /**\n   * Holds the record ID as a string. This ID must follow the Instant spec.\n   *\n   * @member {string} id\n   */\n  override id: string\n\n  /**\n   * Holds the serialized record content.\n   *\n   * @member {?object} content\n   */\n  override content?: ServerRecordsContent\n\n  /**\n   * Holds an Object where the annotations ids are mapped to the Blobs of the records attachments.\n   *\n   * @member {?object} attachments\n   */\n  override attachments: Record<string, Blob>\n\n  /**\n   * Holds the group name of the record\n   *\n   * @type {string|void}\n   */\n  override group?: string | null\n\n  /**\n   * Holds the flag that marks the record as anonymous\n   *\n   * @type {boolean|void}\n   */\n  override isAnonymous?: boolean\n\n  /**\n   * Changes can be `created` for new records, `updated` for existing\n   * records with a new content, or `deleted` for deleted records.\n   *\n   * @member {string} type\n   */\n  override type: 'created' | 'updated' | 'deleted'\n\n  /**\n   * Holds the `Promise#resolve` function for the change request\n   *\n   * @member {Function} resolve\n   */\n  override resolve: (value?: unknown) => void\n\n  /**\n   * Holds the `Promise#reject` function for the change request\n   *\n   * @member {Function} reject\n   */\n  override reject: (error?: Error) => void\n}\n","import { List, Map, OrderedMap, Set } from 'immutable'\nimport type RecordChangeRequest from './RecordChangeRequest'\nimport type Client from '../ClientsPresence/models/Client'\nimport * as Immutable from 'immutable'\n\nexport type InstantSyncAuthPayload = {\n  auth_token: string\n}\n\ninterface IInstantSyncState {\n  requestInfo: {\n    serverURL: string\n    authPayload: InstantSyncAuthPayload\n  } | null\n  status: 'offline' | 'connecting' | 'online'\n  currentClient: Client | null\n  localRecordsContents: OrderedMap<string, Record<string, any>>\n  localRecordsChanges: List<RecordChangeRequest>\n  stagedRecordsChanges: List<RecordChangeRequest>\n  localRecordsRev: number\n  requiredAttachmentIds: Set<string>\n  clients: Map<string, Client>\n}\n\n/**\n * InstantSyncState\n *\n * Describes current state of InstantSync\n */\n\nexport default class InstantSyncState extends Immutable.Record<IInstantSyncState>({\n  requestInfo: null,\n  status: 'offline',\n  currentClient: null,\n  localRecordsContents: OrderedMap(),\n  localRecordsChanges: List(),\n  stagedRecordsChanges: List(),\n  localRecordsRev: 0,\n  requiredAttachmentIds: Set(),\n  clients: Map(),\n}) {\n  /**\n   * Holds the endpoint URL (serverURL) and authentication token to make requests.\n   */\n  override requestInfo: {\n    serverURL: string\n    authPayload: InstantSyncAuthPayload\n  }\n\n  /**\n   * Indication of whether the client is connected to the server or not. Can either be 'offline',\n   * 'connecting' or 'online'.\n   */\n  override status: 'offline' | 'connecting' | 'online'\n  override currentClient: Client\n\n  /**\n   * Holds a map of serialized object contents, which are in sync with the server and have no conflicts\n   */\n  override localRecordsContents: OrderedMap<string, Record<string, any>>\n\n  /**\n   * Holds a list for changes that have been made locally and have not yet been saved on the server.\n   * For every change request (create, update, delete), we will create a new `RecordChangeRequest`\n   * object. This requires us to map every change request to the individual change set and makes\n   * it possible to support changing multiple records at once.\n   */\n  override localRecordsChanges: List<RecordChangeRequest>\n\n  /**\n   * Holds a list for changes that have been made locally and are currently being saved on the server.\n   * For every change request (create, update, delete), we will create a new `RecordChangeRequest`\n   * object. This requires us to map every change request to the individual change set and makes\n   * it possible to support changing multiple records at once.\n   */\n  override stagedRecordsChanges: List<RecordChangeRequest>\n\n  /**\n   * Holds the latest revision of the `localRecordsContents`.\n   */\n  override localRecordsRev: number\n\n  /**\n   * All attachments ids, that need to be attached to the next request.\n   */\n  override requiredAttachmentIds: Set<string>\n\n  /**\n   * A list of all connect clients of every user that is currently present in the record.\n   */\n  override clients: Map<string, Client>\n}\n","import type { Class } from '@/typings/utils'\nimport { List } from 'immutable'\nimport { mergeChanges } from './utils'\nimport { PSPDFKitError } from '@pspdfkit/shared'\nimport RecordChangeRequest from './RecordChangeRequest'\nimport InstantSyncCycle from './InstantSyncCycle'\nimport InstantSyncState from './InstantSyncState'\nimport type { InstantSyncAuthPayload } from './InstantSyncState'\nimport type { InstantSyncResponseChanges } from './InstantSyncCycle'\nimport type { IRecord } from './InstantProvider'\nimport { DEFAULT_LONG_POLLING_TIMEOUT } from './InstantSyncCycle'\nimport { debounceAsync } from '@/utils/debounce'\nimport { ServerRecordsContent } from '@/typings/backend'\n\nexport default class InstantSync {\n  /************************\n   * Record operations\n   ************************/\n  getRecords(): List<IRecord> {\n    this._shouldFireRecordsUpdateCallback = true\n\n    return this._state.localRecordsContents\n      .map((record, id) => {\n        const { content, permissions, group, isAnonymous } = record\n\n        return {\n          content,\n          permissions,\n          group,\n          id,\n          isAnonymous,\n        }\n      })\n      .toList()\n  }\n\n  createRecord(\n    id: string,\n    content: ServerRecordsContent,\n    attachments: Record<string, Blob>,\n    group?: string | null | undefined,\n    isAnonymous?: boolean,\n  ): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const change = new RecordChangeRequest({\n        id,\n        content,\n        attachments,\n        group,\n        type: 'created',\n        isAnonymous,\n        resolve,\n        reject,\n      })\n\n      this.enqueueChangeRequest(change)\n    })\n  }\n\n  updateRecord(id: string, content?: ServerRecordsContent, group?: string, isAnonymous?: boolean) {\n    return new Promise((resolve, reject) => {\n      if (!this.isKnownRecordId(id)) {\n        return reject(new PSPDFKitError(`Record with ID: ${id} not found.`))\n      }\n\n      const change = new RecordChangeRequest({\n        id,\n        content,\n        group,\n        type: 'updated',\n        isAnonymous,\n        resolve,\n        reject,\n      })\n\n      this.enqueueChangeRequest(change)\n    })\n  }\n\n  deleteRecord(id: string) {\n    return new Promise((resolve, reject) => {\n      if (!this.isKnownRecordId(id)) {\n        return reject(new PSPDFKitError(`Record with ID: ${id} not found.`))\n      }\n\n      const change = new RecordChangeRequest({\n        id,\n        type: 'deleted',\n        resolve,\n        reject,\n      })\n\n      this.enqueueChangeRequest(change)\n    })\n  }\n\n  onRecordsUpdates(\n    recordsUpdateCallback: (\n      created: List<Record<string, any>>,\n      updated: List<Record<string, any>>,\n      deleted: List<string>,\n    ) => void,\n    acceptedRecordsCallback: (\n      created: List<Record<string, any>>,\n      updated: List<Record<string, any>>,\n      deleted: List<string>,\n    ) => void,\n  ) {\n    if (typeof recordsUpdateCallback !== 'function') {\n      throw new TypeError('recordsUpdateCallback must be a function')\n    }\n\n    if (typeof acceptedRecordsCallback !== 'function') {\n      throw new TypeError('acceptedRecordsCallback must be a function')\n    }\n\n    this._recordsUpdatesCallback = recordsUpdateCallback\n    this._acceptedRecordsResponseCallback = acceptedRecordsCallback\n  }\n\n  destroy() {\n    if (this._cycle) {\n      this._cycle.destroy()\n    }\n  }\n\n  /**************************\n   * Private Implementation *\n   **************************/\n  _state: InstantSyncState\n  _cycle: InstantSyncCycle\n  _CycleClass: Class<InstantSyncCycle>\n  _recordsUpdatesCallback: (\n    created: List<IRecord>,\n    updated: List<IRecord>,\n    deleted: List<string>,\n  ) => void = () => {}\n  _acceptedRecordsResponseCallback: (\n    created: List<IRecord>,\n    updated: List<IRecord>,\n    deleted: List<string>,\n  ) => void = () => {}\n  _shouldFireRecordsUpdateCallback = false\n\n  /**\n   * For easier testing, we allow a custom state and Cycle class in the constructor.\n   */\n  constructor(\n    state: InstantSyncState = new InstantSyncState(),\n    CycleClass: Class<InstantSyncCycle> = InstantSyncCycle,\n  ) {\n    this._state = state\n    this._CycleClass = CycleClass\n  }\n\n  /**\n   * This method should be called right after the constructor. See {@link InstantSync.load} for the\n   * public abstraction.\n   */\n  load(\n    serverURL: string,\n    authPayload: InstantSyncAuthPayload,\n    listenToServerChangesEnabled = true,\n  ): Promise<InstantSync> {\n    return new Promise((resolve, reject) => {\n      const getState = () => this._state\n\n      const setState = this.setState.bind(this)\n\n      this.setState(\n        this._state.set('requestInfo', {\n          serverURL,\n          authPayload,\n        }),\n      )\n      this._cycle = new this._CycleClass({\n        getState,\n        setState,\n        onChanges: this.onChanges,\n        onAcceptedRecords: this.onAcceptedRecords,\n        longPollingTimeout: listenToServerChangesEnabled ? DEFAULT_LONG_POLLING_TIMEOUT : 0,\n      })\n\n      // Executing the runCycle here also means that we will do the initial synchronization\n      // with the server and fetch the records.\n      this._cycle // We force a timeout of `0` here since we don't want the initial loading to have a delay\n        .nextCycle(0)\n        .then(() => {\n          resolve(this)\n        })\n        .catch(reject)\n    })\n  }\n\n  setState(newState: InstantSyncState): void {\n    this._state = newState\n  }\n\n  onChanges = (changes: InstantSyncResponseChanges): void => {\n    if (this._shouldFireRecordsUpdateCallback) {\n      const { created, updated, deleted } = changes\n\n      this._recordsUpdatesCallback(List(created), List(updated), List(deleted))\n    }\n  }\n  onAcceptedRecords = (accepted: InstantSyncResponseChanges): void => {\n    if (this._shouldFireRecordsUpdateCallback) {\n      const { created, updated, deleted } = accepted\n\n      this._acceptedRecordsResponseCallback(List(created), List(updated), List(deleted))\n    }\n  }\n  setOnDocumentHandleConflictCallback = (callback: () => void): void => {\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function')\n    }\n\n    this._cycle.setOnDocumentHandleConflictCallback(callback)\n  }\n\n  enqueueChangeRequest(changeRequest: RecordChangeRequest): void {\n    const mergedRecordsChanges = mergeChanges({\n      oldChanges: this._state.localRecordsChanges,\n      newChanges: List([changeRequest]),\n    })\n\n    this.setState(this._state.set('localRecordsChanges', mergedRecordsChanges))\n  }\n\n  /**\n   * Performs next sync cycle, pushing `localRecordsChanges` and pulling remote changes.\n   */\n  syncChanges: () => Promise<void> = debounceAsync(() => this._cycle.nextCycle())\n\n  isKnownRecordId(id: string): boolean {\n    function createdChangeWithSameId(change: RecordChangeRequest): boolean {\n      return change.type === 'created' && change.id === id\n    }\n\n    const isSyncedRecord = this._state.localRecordsContents.has(id)\n\n    const isLocalRecord = !!this._state.localRecordsChanges.find(createdChangeWithSameId)\n    const isStagedRecord = !!this._state.stagedRecordsChanges.find(createdChangeWithSameId)\n\n    return isSyncedRecord || isLocalRecord || isStagedRecord\n  }\n}\n","import { Annotation, Comment, FormField } from '../../models'\nimport type { State } from '../../models'\nimport type { IRecord } from './InstantProvider'\n\nexport function getRecordInState(\n  state: State,\n  record: IRecord,\n): Annotation | Comment | FormField | string | undefined {\n  const existingAnnotations = state.get('annotations')\n  const existingFormFields = state.get('formFields')\n  const existingComments = state.get('comments')\n  const existingFormFieldValues = state.get('formattedFormFieldValues')\n  let formFieldName\n\n  if (record.id.startsWith('form-field-value/')) {\n    formFieldName = record.id.split('/')[1]\n  }\n\n  return (\n    existingAnnotations.get(record.id) ||\n    existingFormFields.find(value => value.id === record.id) ||\n    existingComments.get(record.id) ||\n    (formFieldName ? existingFormFieldValues.get(formFieldName) : undefined)\n  )\n}\n\nexport function isRecordInState(state: State, record: IRecord): boolean {\n  return Boolean(getRecordInState(state, record))\n}\n","import type { InstantID } from '@/models/InstantID'\nimport { isPlainObject, invariant } from '@pspdfkit/shared'\nimport { Comment } from '@/models'\nimport {\n  getCollaborationPermissionsFromJSON,\n  ICollaboratorPermissionsOptions,\n  serialiseCollaborationPermissionsProperties,\n  validateCollaborationPermissionJSON,\n} from './collaboration-permissions'\nimport type { CommentJSON } from '@/typings/json/comment'\n\nexport function toJSONComment(comment: Comment): CommentJSON {\n  return {\n    id: comment.id,\n    type: 'pspdfkit/comment',\n    v: 2,\n    rootId: comment.rootId,\n    pageIndex: comment.pageIndex,\n    pdfObjectId: comment.pdfObjectId,\n    creatorName: comment.creatorName,\n    createdAt: comment.createdAt.toISOString(),\n    updatedAt: comment.updatedAt.toISOString(),\n    text: comment.text,\n    customData: comment.customData,\n    isAnonymous: comment.isAnonymous,\n    ...serialiseCollaborationPermissionsProperties(comment),\n  }\n}\n\nexport function fromJSONComment(\n  id: InstantID,\n  json: Omit<CommentJSON, 'id' | 'group' | 'permissions' | 'isAnonymous'>,\n  options?: ICollaboratorPermissionsOptions & {\n    isAnonymous?: boolean | null\n  },\n): Comment {\n  invariant(json.v === 2, 'Unknown comment version')\n  invariant(json.type === 'pspdfkit/comment', 'Invalid comment type')\n  invariant(typeof json.rootId === 'string', '`rootId` must be of type `string`')\n  invariant(typeof json.pageIndex === 'number', '`pageIndex` must be of type `number`')\n  invariant(\n    json.pdfObjectId == null || typeof json.pdfObjectId === 'number',\n    '`pdfObjectId` must be of type `number`',\n  )\n  invariant(\n    json.creatorName == null || typeof json.creatorName === 'string',\n    '`creatorName` must be of type `string`',\n  )\n  invariant(typeof json.text === 'object', '`text` must be of type `object`')\n  invariant(typeof json.text.value === 'string', '`text.value` must be of type `string`')\n  invariant(\n    json.text.format === 'plain' || json.text.format === 'xhtml',\n    '`text.format` must be `plain` or `xhtml`',\n  )\n  invariant(\n    json.customData == null || isPlainObject(json.customData),\n    '`customData` must be a JSON-serializable object',\n  )\n  invariant(\n    typeof options?.isAnonymous === 'undefined' ||\n      typeof options?.isAnonymous === 'boolean' ||\n      options?.isAnonymous === null,\n    '`isAnonymous` should be `undefined` or `boolean`.',\n  )\n  validateCollaborationPermissionJSON(options)\n\n  return new Comment({\n    id,\n    rootId: json.rootId,\n    pageIndex: json.pageIndex,\n    pdfObjectId: json.pdfObjectId,\n    creatorName: json.creatorName,\n    createdAt: json.createdAt ? new Date(json.createdAt) : new Date(0),\n    updatedAt: json.updatedAt ? new Date(json.updatedAt) : new Date(0),\n    text: json.text,\n    customData: json.customData,\n    isAnonymous: options?.isAnonymous,\n    ...getCollaborationPermissionsFromJSON(options),\n  })\n}\n","import { List, Map, Set } from 'immutable'\nimport { error, warn, PSPDFKitError, info, invariant } from '@pspdfkit/shared'\nimport {\n  deserializeAnnotation,\n  deserializeFormFieldValue,\n  isBookmarkJSON,\n  isFormFieldJSON,\n  isFormFieldValueJSON,\n  serializeAnnotation,\n  attachmentsToObject,\n  serializeFormFieldValue,\n  serializeFormField,\n  deserializeFormField,\n  isCommentJSON,\n  isSignatureInfoJSON,\n  isEmbeddedFileJSON,\n} from '../serializers/utils'\nimport {\n  toJSON as serializeBookmark,\n  fromJSON as deserializeBookmark,\n} from '../serializers/BookmarkSerializer'\nimport { CREATE_REASON_LOAD, CREATE_REASON_NEW } from '../Provider'\nimport ClientsPresence from '../ClientsPresence/ClientsPresence'\nimport InstantSync from './InstantSync'\nimport { defaultInstantSettings } from '@/models/InstantSettings'\nimport { getFormFieldValueID } from '@/models/form-fields/FormFieldValue'\nimport { isRecordInState } from './collaboration-permissions'\nimport Annotation from '@/models/annotations/Annotation'\nimport Comment from '@/models/comments/Comment'\nimport FormField from '@/models/form-fields/FormField'\nimport { getRecordInState } from './collaboration-permissions'\nimport {\n  getCollaborationPermissionsFromJSON,\n  validateCollaborationPermissionJSON,\n} from '../serializers/collaboration-permissions'\nimport { shouldShowSignatureFields } from '@/utils/permissions'\nimport { SignatureFormField } from '@/models/form-fields'\nimport { WidgetAnnotation } from '@/models'\n\nimport type { ReadStateProvider, ReadStateProviderCallbacks } from '../ReadStateProvider'\nimport type { AnnotationProvider, AnnotationProviderCallbacks } from '../AnnotationProvider'\nimport type { CreateReason } from '../Provider'\nimport type { Attachment, Bookmark } from '@/models'\nimport type { BookmarkProvider, BookmarkProviderCallbacks } from '../BookmarkProvider'\nimport type { FormFieldValue } from '@/models/form-fields'\nimport type { FormFieldProvider, FormFieldProviderCallbacks } from '../FormFieldProvider'\nimport type { FormFieldValueProvider, FormFieldValueCallbacks } from '../FormFieldValueProvider'\nimport type { ID as AnnotationID } from '@/models/annotations/Annotation'\nimport type { ID as BookmarkID } from '@/models/Bookmark'\nimport type { ID as CommentID } from '@/models/comments/Comment'\nimport type { InstantSyncAuthPayload } from './InstantSyncState'\nimport type Client from '../ClientsPresence/models/Client'\nimport type { InstantID } from '@/models/InstantID'\nimport type { CommentProvider, CommentProviderCallbacks } from '../CommentProvider'\nimport type { InstantSettings } from '@/models/InstantSettings'\nimport type { State } from '@/models'\nimport type { ISignatureFeatureAvailability } from '@/enums/SignatureFeatureAvailability'\nimport type { Class } from '@/typings/utils'\nimport { fromJSONComment, toJSONComment } from '@/lib/serializers/CommentSerializer'\nimport { AnnotationsUnion, AnnotationsBackendJSONUnion } from '@/typings/serializers'\nimport { CommentJSON } from '@/typings/json/comment'\nimport { FormFieldJSON } from '@/typings/json/formField'\nimport { ServerRecordsContent } from '@/typings/backend'\n\nexport type IRecord = {\n  id: string\n  content?: ServerRecordsContent | null\n  group?: string | null | undefined\n  permissions?: {\n    edit: boolean\n    delete: boolean\n    view: boolean\n    setGroup: boolean\n  }\n  isAnonymous?: boolean\n}\n\n/**\n * InstantProvider is an implementation of the AnnotationProvider that,\n * using the `/sync` endpoint, allows the client to sync with other devices and\n * benefit from server side conflict resolution.\n *\n * `createAnnotation` and `updateAnnotation` perform optimistic updates which are reverted\n * in case of conflicts with newer updates coming from the server.\n * `deleteAnnotation` instead is signed off only after the server has accepted the change\n * since in this case roll back and restore the annotation would be harder.\n */\nexport class InstantProvider\n  implements\n    ReadStateProvider,\n    AnnotationProvider,\n    BookmarkProvider,\n    FormFieldProvider,\n    FormFieldValueProvider,\n    CommentProvider\n{\n  _readStateCallbacks?: ReadStateProviderCallbacks\n  _annotationCallbacks?: AnnotationProviderCallbacks\n  _bookmarkCallbacks?: BookmarkProviderCallbacks\n  _formFieldCallbacks?: FormFieldProviderCallbacks\n  _formFieldValueCallbacks?: FormFieldValueCallbacks\n  _commentCallbacks?: CommentProviderCallbacks\n  // We keep track of the bookmarks IDs when we create new bookmarks\n  // because Instant sends a List of IDs when some deletion occurred.\n  // In such cases we can use this list to determine whether we are dealing with\n  // a bookmarks or annotation deletion.\n  _existingBookmarksIds: Set<BookmarkID> = Set()\n  _existingFormFieldsIds: Set<AnnotationID> = Set()\n  _existingFormFieldValuesIds: Set<string> = Set()\n  _existingCommentIds: Set<InstantID> = Set()\n  _sync: InstantSync\n  _clients?: ClientsPresence\n  _documentURL: string\n  _serverURL: string\n  _settings: InstantSettings\n  _authPayload: InstantSyncAuthPayload\n  _hasLoadedInitialRecords: boolean\n  _loadPromise: Promise<void> | null | undefined\n  _getState: () => State\n  _formsEnabledInConfig: boolean\n  onClientsChangeCallback: (clients: Map<string, Client>) => void\n  _documentHandleConflictCallback: () => void = () => {}\n  _setDocumentHandleOutdatedCallback: (arg0: boolean) => void\n  _setReadStateCallbacksPromiseResolve: (() => void) | null\n  _setReadStateCallbacksPromise: Promise<void>\n  canCreateBackendOrphanWidgets = true\n\n  constructor(\n    serverURL: string,\n    documentURL: string,\n    authPayload: InstantSyncAuthPayload,\n    settings: InstantSettings = defaultInstantSettings,\n  ) {\n    this._serverURL = serverURL\n    this._documentURL = documentURL\n    this._authPayload = authPayload\n    this._settings = settings\n    this._hasLoadedInitialRecords = false\n    this._setReadStateCallbacksPromise = new Promise(resolve => {\n      this._setReadStateCallbacksPromiseResolve = resolve\n    })\n  }\n\n  load(\n    SyncClass: Class<InstantSync> = InstantSync,\n    ClientsPresenceClass: Class<ClientsPresence> = ClientsPresence,\n  ): Promise<InstantProvider> {\n    const initializationPromises: Promise<InstantSync | void>[] = []\n\n    // Initialize sync.\n    this._sync = new SyncClass()\n    initializationPromises.push(\n      this._sync\n        .load(\n          `${this._documentURL}/sync`,\n          this._authPayload,\n          this._settings.listenToServerChangesEnabled,\n        )\n        .catch(error),\n    )\n\n    this._sync.setOnDocumentHandleConflictCallback(this.onDocumentHandleConflict)\n\n    if (this._settings.clientsPresenceEnabled) {\n      // Initialize clients presence.\n      this._clients = new ClientsPresenceClass()\n      initializationPromises.push(\n        this._clients\n          .load(`${this._serverURL.replace(/^http/i, 'ws')}/websocket`, this._authPayload, {})\n          .then(() => {\n            const clients = this._clients\n\n            if (clients == null) return\n\n            // Register callback\n            clients.onClientUpdates(() => this._onClientsChange(clients.getClients()))\n\n            // Handle initial clients the same way as a clients updates callback\n            this._onClientsChange(clients.getClients())\n          })\n          .catch(error => {\n            warn(\n              'PSPDFKit: An error occurred while initializing the connected clients module. ' +\n                'This might be due to a lack of support for WebSockets or a related failure.\\n\\n' +\n                'Failure details:\\n\\n' +\n                error.message,\n            )\n          }),\n      )\n    }\n\n    return Promise.all(initializationPromises)\n      .then(() => {\n        return this\n      })\n      .catch(error => {\n        throw new PSPDFKitError(`Initialization of PSPDFKit Instant failed:\n${error.message}`)\n      })\n  }\n\n  destroy() {\n    if (this._sync) {\n      this._sync.destroy()\n    }\n  }\n\n  setFormsEnabledInConfig(formsEnabledInConfig: boolean) {\n    this._formsEnabledInConfig = formsEnabledInConfig\n  }\n\n  setReadStateCallbacks(readStateCallbacks: ReadStateProviderCallbacks) {\n    this._readStateCallbacks = readStateCallbacks\n\n    this._setReadStateCallbacksPromiseResolve?.()\n  }\n\n  setAnnotationCallbacks(annotationCallbacks: AnnotationProviderCallbacks) {\n    this._annotationCallbacks = annotationCallbacks\n  }\n\n  setBookmarkCallbacks(bookmarkCallbacks: BookmarkProviderCallbacks) {\n    this._bookmarkCallbacks = bookmarkCallbacks\n  }\n\n  setFormFieldCallbacks(formFieldCallbacks: FormFieldProviderCallbacks) {\n    this._formFieldCallbacks = formFieldCallbacks\n  }\n\n  setFormFieldValueCallbacks(formFieldValueCallbacks: FormFieldValueCallbacks) {\n    this._formFieldValueCallbacks = formFieldValueCallbacks\n  }\n\n  setCommentCallbacks(commentCallbacks: CommentProviderCallbacks) {\n    this._commentCallbacks = commentCallbacks\n  }\n\n  createAnnotation(annotation: Annotation, attachments: Map<string, Attachment>): Promise<void> {\n    const { id, ...data } = serializeAnnotation(annotation)\n    const { group, permissions, ...content } = data\n\n    invariant(id, 'Annotation id must be defined.')\n\n    return this._sync.createRecord(id, content, attachmentsToObject(attachments), group)\n  }\n\n  createComment(comment: Comment): Promise<void> {\n    const { id, ...data } = toJSONComment(comment)\n\n    // destructuring permissions to remove if from content.\n    const { group, permissions, isAnonymous, ...content } = data\n    invariant(id, 'Comment id must be defined.')\n\n    this._existingCommentIds = this._existingCommentIds.add(id)\n\n    return this._sync.createRecord(id, content, {}, group, !!isAnonymous)\n  }\n\n  async updateComment(comment: Comment) {\n    try {\n      await this.updateRecord(toJSONComment(comment))\n    } catch (e) {\n      if (!(e instanceof PSPDFKitError)) {\n        throw e\n      }\n    }\n  }\n\n  deleteComment(commentId: InstantID): Promise<void> {\n    this._existingCommentIds = this._existingCommentIds.delete(commentId)\n\n    return this._sync.deleteRecord(commentId).then(() => {})\n  }\n\n  setStateGetter(getState: () => State): void {\n    this._getState = getState\n  }\n\n  async updateRecord(data: AnnotationsBackendJSONUnion | FormFieldJSON | CommentJSON) {\n    const { id, permissions, isAnonymous, group, ...content } =\n      data.type === 'pspdfkit/comment' ? data : { ...data, isAnonymous: undefined }\n\n    invariant(id, 'Record id must be defined.')\n\n    if (this._getState?.()?.backend?.isCollaborationPermissionsEnabled()) {\n      invariant(permissions, 'Permissions must be defined.')\n\n      return this._sync.updateRecord(\n        id,\n        permissions.edit ? content : undefined,\n        permissions.setGroup ? group ?? undefined : undefined,\n        isAnonymous ?? undefined,\n      )\n    } else {\n      return this._sync.updateRecord(id, content, group ?? undefined, isAnonymous ?? undefined)\n    }\n  }\n\n  async updateAnnotation(annotation: AnnotationsUnion) {\n    try {\n      await this.updateRecord(serializeAnnotation(annotation))\n    } catch (e) {\n      if (!(e instanceof PSPDFKitError)) {\n        throw e\n      }\n    }\n  }\n\n  deleteAnnotation(annotation: Annotation) {\n    return this._sync.deleteRecord(annotation.id).then(() => {})\n  }\n\n  createBookmark(bookmark: Bookmark) {\n    const { id, ...content } = serializeBookmark(bookmark)\n\n    this._existingBookmarksIds = this._existingBookmarksIds.add(id)\n\n    return this._sync.createRecord(id, content, {})\n  }\n\n  async updateBookmark(bookmark: Bookmark) {\n    const { id, ...content } = serializeBookmark(bookmark)\n\n    try {\n      await this._sync.updateRecord(id, content)\n    } catch (e) {\n      if (!(e instanceof PSPDFKitError)) {\n        throw e\n      }\n    }\n  }\n\n  deleteBookmark(bookmarkId: BookmarkID): Promise<void> {\n    return this._sync.deleteRecord(bookmarkId).then(() => {\n      this._existingBookmarksIds = this._existingBookmarksIds.delete(bookmarkId)\n    })\n  }\n\n  createFormField(formField: FormField) {\n    // destructuring permissions to remove if from content.\n    const { group, permissions, id, ...content } = serializeFormField(formField)\n\n    this._existingFormFieldsIds = this._existingFormFieldsIds.add(id)\n\n    return this._sync.createRecord(id, content, {}, group)\n  }\n\n  async updateFormField(formField: FormField): Promise<void> {\n    try {\n      await this.updateRecord(serializeFormField(formField))\n    } catch (e) {\n      if (!(e instanceof PSPDFKitError)) {\n        throw e\n      }\n    }\n  }\n\n  deleteFormField(formField: FormField): Promise<void> {\n    return this._sync.deleteRecord(formField.id).then(() => {\n      this._existingFormFieldsIds = this._existingFormFieldsIds.delete(formField.id)\n    })\n  }\n\n  // Form fields are retrieved in the annotations list\n  loadFormFields(): Promise<void> {\n    return this.loadAnnotationsForPageIndex()\n  }\n\n  createFormFieldValue(formFieldValue: FormFieldValue): Promise<void> {\n    const content = serializeFormFieldValue(formFieldValue)\n    const id = getFormFieldValueID(formFieldValue)\n\n    this._existingFormFieldValuesIds = this._existingFormFieldValuesIds.add(id)\n\n    return this._sync.createRecord(id, content, {})\n  }\n\n  async setFormFieldValue(formFieldValue: FormFieldValue): Promise<void> {\n    const content = serializeFormFieldValue(formFieldValue)\n\n    try {\n      await this._sync.updateRecord(getFormFieldValueID(formFieldValue), content)\n    } catch (e) {\n      if (!(e instanceof PSPDFKitError)) {\n        throw e\n      }\n    }\n  }\n\n  deleteFormFieldValue(id: string): Promise<void> {\n    return this._sync.deleteRecord(id).then(() => {\n      this._existingFormFieldValuesIds = this._existingFormFieldValuesIds.delete(id)\n    })\n  }\n\n  loadAnnotationsForPageIndex(): Promise<void> {\n    // We only ever start listening to real time changes and emit events when\n    // the first page loading was initiated. This will make the behavior of the\n    // Instant annotation provider similar to what we do on the others (where we\n    // do not pre-download all annotations). This is necessary because we might\n    // not handle some callbacks before that.\n    //\n    // This also has impact on JavaScript support. We now load form fields the\n    // same way as annotations when the form designer feature is present which\n    // means form fields will not be present until the first pages have been\n    // loaded. JavaScript however might interpret document level scripts before\n    // that which will cause warnings when form fields are not initialized. See\n    // comment in connect.js before calling applyJavaScriptActionChanges.\n    //\n    // @FIXME(philipp): We need to clean that up and find a way to avoid the\n    // push to the next macro queue.\n    if (this._loadPromise) {\n      return this._loadPromise\n    }\n\n    this._loadPromise = new Promise(resolve => setTimeout(resolve, 0)).then(() => {\n      if (!this._hasLoadedInitialRecords) {\n        // Register callback\n        this._sync.onRecordsUpdates(\n          // @ts-expect-error\n\n          (c, u, d) => this._onRecordsUpdates(c, u, d, CREATE_REASON_NEW),\n          // @ts-expect-error\n          (c, u, d) => this._onAcceptedRecords(c, u, d),\n        )\n\n        // Handle initial annotations list the same way as an annotations updates callback\n        this._onRecordsUpdates(this._sync.getRecords(), List(), List(), CREATE_REASON_LOAD)\n\n        this._hasLoadedInitialRecords = true\n      }\n    })\n\n    return this._loadPromise\n  }\n\n  async loadBookmarks(): Promise<void> {\n    return\n  }\n\n  syncChanges(): Promise<void> {\n    return this._sync.syncChanges()\n  }\n\n  /**\n   * In a situation where the user has set `disableForms: true` in the configuration,\n   * we don't set `this._formFieldCallbacks` and `this._formsEnabledInConfig` is set to `false` but the server doesn't know that and keeps\n   * sending the record updates for widgets. In that case we need to filter and remove\n   * the record that are widgets if `this.__formsEnabledInConfig` is set to `false`.\n   * @param records\n   * @private\n   */\n  _filterRecords(records: List<IRecord>): List<IRecord> {\n    return records.filter(({ content }) => this._formsEnabledInConfig || !isFormFieldJSON(content))\n  }\n\n  /******************************\n   * Internal Callback Handlers *\n   ******************************/\n  _onRecordsUpdates(\n    created: List<IRecord>,\n    updated: List<IRecord>,\n    deleted: List<string>,\n    createReason: CreateReason,\n  ) {\n    let mutableBookmarkAdditions: List<Bookmark> = List()\n    const mutableFormFieldAdditions: Array<FormField> = []\n    let mutableFormFieldValueAdditions: List<FormFieldValue> = List()\n    let mutableCommentAdditions: List<Comment> = List()\n    let deletions = Set() // we also remove updated annotations that encountered an error during deserializing\n\n    let bookmarkDeletions = Set() // we also remove updated bookmarks that encountered an error during deserializing\n\n    let formFieldDeletions = Set() // we also remove updated form fields that encountered an error during deserializing\n\n    let formFieldValueDeletions = Set() // we also remove updated form field values that encountered an error during deserializing\n\n    let commentDeletions = Set()\n    const state = this._getState ? this._getState() : undefined\n    let _created = created\n    let _updated = updated\n    let _deleted = deleted\n\n    if (state && state.backend && state.backend.isCollaborationPermissionsEnabled()) {\n      _created = _created.filter(({ content }) => !!content)\n\n      const updatesIndexToBeRemoved: number[] = []\n\n      updated.forEach((record, index) => {\n        if (!record.content) {\n          if (isRecordInState(state, record)) {\n            // If we receive a record with no content and it’s present in our store,\n            // it means it’s visibility permission was set to hidden and\n            // we delete the record from our store.\n            _deleted = _deleted.push(record.id)\n            updatesIndexToBeRemoved.push(index)\n          } else {\n            // If we receive a record with no content and it’s not present in our store, we do nothing.\n            updatesIndexToBeRemoved.push(index)\n          }\n        } else if (!isRecordInState(state, record)) {\n          // If we receive a record with content which isn’t present in our store, it means the visibility permission was changed.\n          // In that case, we will create a new record.\n          _created = _created.push(record)\n          updatesIndexToBeRemoved.push(index)\n        }\n      })\n      _updated = _updated.filter((_record, index) => !updatesIndexToBeRemoved.includes(index))\n      _deleted = _deleted.filter(\n        d =>\n          state.annotations.has(d) ||\n          this._existingFormFieldValuesIds.has(d) ||\n          this._existingFormFieldsIds.has(d) ||\n          this._existingCommentIds.has(d) ||\n          this._existingBookmarksIds.has(d),\n      )\n    }\n\n    let additions = List().withMutations(mutableAdditions => {\n      this._filterRecords(_created).forEach(({ id, content, permissions, group, isAnonymous }) => {\n        const options = {\n          permissions,\n          group,\n          isAnonymous,\n        }\n\n        try {\n          if (isFormFieldJSON(content)) {\n            mutableFormFieldAdditions.push(deserializeFormField(id, content, options))\n            this._existingFormFieldsIds = this._existingFormFieldsIds.add(id)\n          } else if (isFormFieldValueJSON(content)) {\n            mutableFormFieldValueAdditions = mutableFormFieldValueAdditions.push(\n              deserializeFormFieldValue(content),\n            )\n            this._existingFormFieldValuesIds = this._existingFormFieldValuesIds.add(id)\n          } else if (isBookmarkJSON(content)) {\n            // TODO figure out why when I use mutableBookmarkAdditions asMutable() push produces a list of IDs only 🤷‍♂️\n            mutableBookmarkAdditions = mutableBookmarkAdditions.push(\n              deserializeBookmark(id, content),\n            )\n            this._existingBookmarksIds = this._existingBookmarksIds.add(id)\n          } else if (isCommentJSON(content)) {\n            this._existingCommentIds = this._existingCommentIds.add(id)\n            mutableCommentAdditions = mutableCommentAdditions.push(\n              fromJSONComment(id, content, options),\n            )\n          } else if (isSignatureInfoJSON(content)) {\n            // No-op on digital signatures changes since we won't be syncing signatures\n            // on real-time\n          } else if (isEmbeddedFileJSON(content)) {\n            // No-op since web does not support embedded files yet.\n          } else {\n            // @ts-expect-error\n            mutableAdditions.push(deserializeAnnotation(id, content, options))\n          }\n        } catch (error) {\n          info(\n            `Skipped creating record #${id} from payload because an error occurred while deserializing.`,\n            // @ts-expect-error\n            content,\n          )\n          info(error)\n        }\n      })\n    })\n    const showSignatures = state\n      ? shouldShowSignatureFields(\n          state.features,\n          state.signatureFeatureAvailability as ISignatureFeatureAvailability,\n        )\n      : true\n\n    if (mutableFormFieldAdditions.length > 0) {\n      invariant(this._formFieldCallbacks)\n\n      if (state && !showSignatures) {\n        // Although Server returns all form fields, if the needed license features\n        // combination is not given, we should avoid to add signature form fields.\n        // See https://docs.google.com/document/d/1ry0uJIGAgUPa6cmjCWCKRC5zReqdfpROuQyhOt7GXNs/edit#heading=h.dlbwh9b87wv3\n        this._formFieldCallbacks.createFormFields(\n          List(\n            mutableFormFieldAdditions.filter(\n              formField => !(formField instanceof SignatureFormField),\n            ),\n          ),\n          createReason,\n        )\n      } else {\n        this._formFieldCallbacks.createFormFields(List(mutableFormFieldAdditions), createReason)\n      }\n    }\n\n    if (additions.size > 0) {\n      invariant(this._annotationCallbacks)\n\n      if (state && !showSignatures) {\n        // Don't store widgets associated to ignored form fields on step above\n        additions = additions.filter(annotation => {\n          if (!(annotation instanceof WidgetAnnotation)) {\n            return annotation\n          }\n\n          const formField =\n            mutableFormFieldAdditions.find(field => field.name === annotation.formFieldName) ||\n            state.formFields.get(annotation.formFieldName)\n\n          return !(formField && formField instanceof SignatureFormField)\n        })\n      }\n\n      this._annotationCallbacks.createAnnotations(additions, Map(), createReason)\n    }\n\n    if (mutableFormFieldValueAdditions.size > 0) {\n      invariant(this._formFieldValueCallbacks)\n\n      if (state && !showSignatures) {\n        // Take into account purposefully ignored form fields from step above\n        mutableFormFieldValueAdditions = mutableFormFieldValueAdditions.filter(value => {\n          const formField =\n            mutableFormFieldAdditions.find(field => field.name === value.name) ||\n            // @ts-expect-error\n            state.formFields.get(value.formFieldName)\n\n          return !(formField && formField instanceof SignatureFormField)\n        })\n      }\n\n      this._formFieldValueCallbacks.createFormFieldValues(\n        List(mutableFormFieldValueAdditions),\n        createReason,\n      )\n    }\n\n    if (mutableCommentAdditions.size > 0) {\n      invariant(this._commentCallbacks)\n\n      this._commentCallbacks.createComments(mutableCommentAdditions, createReason)\n    }\n\n    if (mutableBookmarkAdditions.size > 0) {\n      invariant(this._bookmarkCallbacks)\n\n      this._bookmarkCallbacks.createBookmarks(mutableBookmarkAdditions, createReason)\n    }\n\n    const mutableBookmarkChanges: List<Bookmark> = List().asMutable()\n    const mutableFormFieldChanges: Array<FormField> = []\n    const mutableFormFieldValueChanges: Array<FormFieldValue> = []\n    const mutableCommentChanges: Array<Comment> = []\n    const updates = List().withMutations(mutableUpdates => {\n      this._filterRecords(_updated).forEach(({ id, content, group, permissions, isAnonymous }) => {\n        const options = {\n          permissions,\n          group,\n          isAnonymous,\n        }\n\n        try {\n          if (isFormFieldJSON(content)) {\n            try {\n              mutableFormFieldChanges.push(deserializeFormField(id, content, options))\n            } catch (error) {\n              formFieldDeletions = formFieldDeletions.add(id)\n              info(\n                `Skipped updating form field #${id} from payload because an error occurred while deserializing. To avoid issues, we have removed the previous version from the application state.`,\n                // @ts-expect-error\n                content,\n              )\n              info(error)\n            }\n          } else if (isFormFieldValueJSON(content)) {\n            try {\n              mutableFormFieldValueChanges.push(deserializeFormFieldValue(content))\n            } catch (error) {\n              formFieldValueDeletions = formFieldValueDeletions.add(id)\n              info(\n                `Skipped updating form field value #${id} from payload because an error occurred while deserializing. To avoid issues, we have removed the previous version from the application state.`,\n                // @ts-expect-error\n                content,\n              )\n              info(error)\n            }\n          } else if (isBookmarkJSON(content)) {\n            try {\n              mutableBookmarkChanges.push(deserializeBookmark(id, content))\n            } catch (error) {\n              bookmarkDeletions = bookmarkDeletions.add(id)\n              info(\n                `Skipped updating bookmark #${id} from payload because an error occurred while deserializing. To avoid issues, we have removed the previous version from the application state.`,\n                // @ts-expect-error\n                content,\n              )\n              info(error)\n            }\n          } else if (isCommentJSON(content)) {\n            try {\n              mutableCommentChanges.push(fromJSONComment(id, content, options))\n            } catch (error) {\n              commentDeletions = commentDeletions.add(id)\n              info(\n                `Skipped updating comment #${id} from payload because an error occurred while deserializing. To avoid issues, we have removed the previous version from the application state.`,\n                // @ts-expect-error\n                content,\n                error,\n              )\n            }\n          } else {\n            // @ts-expect-error\n            mutableUpdates.push(deserializeAnnotation(id, content, options))\n          }\n        } catch (error) {\n          deletions = deletions.add(id)\n          info(\n            `Skipped updating annotation #${id} from payload because an error occurred while deserializing. To avoid issues, we have removed the previous version from the application state.`,\n            // @ts-expect-error\n            content,\n          )\n          info(error)\n        }\n      })\n    })\n\n    if (updates.size > 0) {\n      invariant(this._annotationCallbacks)\n\n      this._annotationCallbacks.updateAnnotations(updates)\n    }\n\n    if (mutableBookmarkChanges.size > 0) {\n      invariant(this._bookmarkCallbacks)\n\n      this._bookmarkCallbacks.updateBookmarks(mutableBookmarkChanges)\n    }\n\n    if (mutableFormFieldChanges.length > 0) {\n      invariant(this._formFieldCallbacks)\n\n      this._formFieldCallbacks.updateFormFields(List(mutableFormFieldChanges))\n    }\n\n    if (mutableFormFieldValueChanges.length > 0) {\n      invariant(this._formFieldValueCallbacks)\n\n      this._formFieldValueCallbacks.setFormFieldValues(List(mutableFormFieldValueChanges))\n    }\n\n    if (mutableCommentChanges.length > 0) {\n      invariant(this._commentCallbacks)\n\n      this._commentCallbacks.updateComments(List(mutableCommentChanges))\n    }\n\n    deletions = deletions.concat(\n      _deleted\n        .filter(\n          id =>\n            !this._existingBookmarksIds.has(id) &&\n            !this._existingFormFieldsIds.has(id) &&\n            !this._existingFormFieldValuesIds.has(id) &&\n            !this._existingCommentIds.has(id),\n        )\n        .toSet(),\n    )\n\n    if (deletions.size > 0) {\n      invariant(this._annotationCallbacks)\n\n      this._annotationCallbacks.deleteAnnotations(deletions)\n    }\n\n    bookmarkDeletions = bookmarkDeletions.concat(\n      _deleted\n        .filter(id => {\n          const isBookmarkDeletion = this._existingBookmarksIds.has(id)\n\n          if (isBookmarkDeletion) {\n            this._existingBookmarksIds = this._existingBookmarksIds.delete(id)\n          }\n\n          return isBookmarkDeletion\n        })\n        .toSet(),\n    )\n\n    if (bookmarkDeletions.size > 0) {\n      invariant(this._bookmarkCallbacks)\n\n      this._bookmarkCallbacks.deleteBookmarks(bookmarkDeletions)\n    }\n\n    formFieldDeletions = formFieldDeletions.concat(\n      _deleted\n        .filter(id => {\n          const isFormFieldDeletion = this._existingFormFieldsIds.has(id)\n\n          if (isFormFieldDeletion) {\n            this._existingFormFieldsIds = this._existingFormFieldsIds.delete(id)\n          }\n\n          return isFormFieldDeletion\n        })\n        .toSet(),\n    )\n\n    if (formFieldDeletions.size > 0) {\n      invariant(this._formFieldCallbacks)\n\n      this._formFieldCallbacks.deleteFormFields(formFieldDeletions)\n    }\n\n    formFieldValueDeletions = formFieldValueDeletions.concat(\n      _deleted\n        .filter(id => {\n          const isFormFieldValueDeletion = this._existingFormFieldValuesIds.has(id)\n\n          if (isFormFieldValueDeletion) {\n            this._existingFormFieldValuesIds = this._existingFormFieldValuesIds.delete(id)\n          }\n\n          return isFormFieldValueDeletion\n        })\n        .toSet(),\n    )\n\n    if (formFieldValueDeletions.size > 0) {\n      invariant(this._formFieldValueCallbacks)\n\n      this._formFieldValueCallbacks.deleteFormFieldValues(formFieldValueDeletions)\n    }\n\n    commentDeletions = commentDeletions.concat(\n      _deleted\n        .filter(id => {\n          const commentDeletion = this._existingCommentIds.has(id)\n\n          if (commentDeletion) {\n            this._existingCommentIds = this._existingCommentIds.delete(id)\n          }\n\n          return commentDeletion\n        })\n        .toSet(),\n    )\n\n    if (commentDeletions.size > 0) {\n      invariant(this._commentCallbacks)\n\n      this._commentCallbacks.deleteComments(commentDeletions)\n    }\n  }\n\n  _onAcceptedRecords(created: List<IRecord>, updated: List<IRecord>) {\n    const state = this._getState ? this._getState() : undefined\n\n    if (!state || !state.backend || !state.backend.isCollaborationPermissionsEnabled()) {\n      return\n    }\n\n    // When Collaboration Permissions are enabled we need to update the locally created or updated\n    // records so that they include the proper permissions enforced by the backend.\n    const annotationsUpdates: Array<Annotation> = []\n    const commentsUpdates: Array<Comment> = []\n    const formFieldsUpdates: Array<FormField> = []\n    // We also need to remove records from the Redux store if Server doesn't assign view\n    // permissions\n    const deletableAnnotations: Array<AnnotationID> = []\n    const deletableComments: Array<BookmarkID> = []\n    const deletableFormFields: Array<CommentID> = []\n\n    if (!created.isEmpty()) {\n      created.forEach(mergePermissionsOnRecords)\n    }\n\n    if (!updated.isEmpty()) {\n      updated.forEach(mergePermissionsOnRecords)\n    }\n\n    if (annotationsUpdates.length > 0) {\n      invariant(this._annotationCallbacks)\n\n      // @ts-expect-error\n      this._annotationCallbacks.updateAnnotations(List(annotationsUpdates), true)\n    }\n\n    if (commentsUpdates.length > 0) {\n      invariant(this._commentCallbacks)\n\n      this._commentCallbacks.updateComments(List(commentsUpdates))\n    }\n\n    if (formFieldsUpdates.length > 0) {\n      invariant(this._formFieldCallbacks)\n\n      this._formFieldCallbacks.updateFormFields(List(formFieldsUpdates))\n    }\n\n    if (deletableAnnotations.length > 0) {\n      invariant(this._annotationCallbacks)\n\n      // @ts-expect-error\n      this._annotationCallbacks.deleteAnnotations(Set(deletableAnnotations), true)\n    }\n\n    if (deletableComments.length > 0) {\n      invariant(this._commentCallbacks)\n\n      this._commentCallbacks.deleteComments(Set(deletableComments))\n    }\n\n    if (deletableFormFields.length > 0) {\n      invariant(this._formFieldCallbacks)\n\n      this._formFieldCallbacks.deleteFormFields(Set(deletableFormFields))\n    }\n\n    function mergePermissionsOnRecords(record: IRecord) {\n      const options = {\n        permissions: record.permissions,\n        group: record.group,\n      }\n      let entity = getRecordInState(state as State, record)\n\n      // We can ignore form field values responses (string type)\n      if (entity && typeof entity !== 'string') {\n        validateCollaborationPermissionJSON(options)\n\n        const collaborationPermissions = getCollaborationPermissionsFromJSON(options)\n\n        entity = entity.merge(collaborationPermissions)\n\n        if (entity instanceof Annotation) {\n          if (options.permissions && options.permissions.view) {\n            annotationsUpdates.push(entity)\n          } else {\n            deletableAnnotations.push(entity.id)\n          }\n        } else if (entity instanceof Comment) {\n          if (options.permissions && options.permissions.view) {\n            commentsUpdates.push(entity)\n          } else {\n            invariant(entity.id)\n            deletableComments.push(entity.id)\n          }\n        } else if (entity instanceof FormField) {\n          if (options.permissions && options.permissions.view) {\n            formFieldsUpdates.push(entity)\n          } else {\n            deletableFormFields.push(entity.id)\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Sets the on clients change callback. Will be overwritten when another callback is set.\n   */\n  onClientsChange(onClientsChangeCallback: (clients: Map<string, Client>) => void): void {\n    if (typeof onClientsChangeCallback !== 'function') {\n      throw new TypeError('Callback must be a function')\n    }\n\n    this.onClientsChangeCallback = onClientsChangeCallback\n  }\n\n  _onClientsChange(clients: Map<string, Client>): void {\n    this.onClientsChangeCallback.call(null, clients)\n  }\n\n  /**\n   * Document handle conflict callback handlers.\n   */\n\n  /**\n   * Set by ServerBackend after instantiating the provider\n   */\n  setDocumentHandleConflictCallback = (callback: () => void) => {\n    this._documentHandleConflictCallback = callback\n  }\n\n  /**\n   * Set in utils/document by setupManagers() on connect and reconnect\n   */\n  setDocumentHandleOutdated = (callback: (arg0: boolean) => void) => {\n    this._setDocumentHandleOutdatedCallback = callback\n  }\n\n  /**\n   * Callback passed to InstantSync when instantiating it\n   */\n  onDocumentHandleConflict = () => {\n    this._documentHandleConflictCallback && this._documentHandleConflictCallback()\n    this._setDocumentHandleOutdatedCallback && this._setDocumentHandleOutdatedCallback(true)\n  }\n}\n"],"names":["Client","Immutable","clientId","userId","presenceContent","ClientsPresenceState","status","currentClient","clients","Map","Timer","constructor","callback","timerCalc","this","timer","tries","reset","clearTimeout","scheduleTimeout","setTimeout","CLIENT_VERSION","SOCKET_STATES","CLIENT_INFO","name","defaultReconnectTimerCalc","n","WebsocketConnection","serverURL","authPayload","reconnectTimerCalc","enableReconnect","events","eventEmitter","EventEmitter","concat","socket","lastRequestId","requestsWaitingForAnswers","reconnectTimer","close","connect","clearAuthenticationInformation","registerEvents","push","WebSocket","onopen","onOpen","bind","onmessage","onMessage","onerror","emit","disconnect","onclose","abortOpenRequests","connectionState","readyState","isAuthenticated","sendRequest","action","payload","Promise","resolve","reject","PSPDFKitError","requestId","nextRequestId","serializedPayload","JSON","stringify","set","send","on","off","onError","onClose","message","data","frame","parseFrame","invariant","has","request","get","reason","delete","includes","log","parseUnauthenticatedFrame","onHello","onAuthenticated","event","error","protocol_version","requestPayload","client_version","client_info","auth_payload","client_id","user_id","getEnvironment","args","console","requestIdOrInfo","exec","toString","parseInt","parse","forEach","clientFromPayload","presence","ClientsPresence","state","connectionClass","load","initialPresenceContent","setState","newState","connection","session","populateClients","then","catch","onInfoClientPresence","withMutations","mutableState","map","clientPayload","c","setClientsAction","newClients","mutableClients","entered","client","updated","left","applyClientChangesAction","shouldFireClientUpdatesCallback","enteredClientIds","filter","indexOf","toMap","updatedClientIds","List","clientUpdatesCallback","getStatus","getCurrentClient","getClients","updatePresence","setIn","updateCurrentClientPresenceAction","onClientUpdates","TypeError","RecordChangeRequest","content","attachments","id","type","isAnonymous","undefined","group","InstantSyncState","requestInfo","localRecordsContents","OrderedMap","localRecordsChanges","stagedRecordsChanges","localRecordsRev","requiredAttachmentIds","Set","InstantSync","getRecords","_shouldFireRecordsUpdateCallback","_state","record","permissions","toList","createRecord","change","enqueueChangeRequest","updateRecord","isKnownRecordId","deleteRecord","onRecordsUpdates","recordsUpdateCallback","acceptedRecordsCallback","_recordsUpdatesCallback","_acceptedRecordsResponseCallback","destroy","_cycle","CycleClass","InstantSyncCycle","_CycleClass","listenToServerChangesEnabled","getState","onChanges","onAcceptedRecords","longPollingTimeout","DEFAULT_LONG_POLLING_TIMEOUT","nextCycle","changes","created","deleted","accepted","setOnDocumentHandleConflictCallback","changeRequest","mergedRecordsChanges","mergeChanges","oldChanges","newChanges","syncChanges","debounceAsync","createdChangeWithSameId","isSyncedRecord","isLocalRecord","find","isStagedRecord","getRecordInState","existingAnnotations","existingFormFields","existingComments","existingFormFieldValues","formFieldName","startsWith","split","value","isRecordInState","Boolean","toJSONComment","comment","v","rootId","pageIndex","pdfObjectId","creatorName","createdAt","toISOString","updatedAt","text","customData","serialiseCollaborationPermissionsProperties","fromJSONComment","json","options","format","isPlainObject","validateCollaborationPermissionJSON","Comment","Date","getCollaborationPermissionsFromJSON","InstantProvider","_existingBookmarksIds","_existingFormFieldsIds","_existingFormFieldValuesIds","_existingCommentIds","_documentHandleConflictCallback","canCreateBackendOrphanWidgets","documentURL","settings","defaultInstantSettings","_serverURL","_documentURL","_authPayload","_settings","_hasLoadedInitialRecords","_setReadStateCallbacksPromise","_setReadStateCallbacksPromiseResolve","SyncClass","ClientsPresenceClass","initializationPromises","_sync","onDocumentHandleConflict","clientsPresenceEnabled","_clients","replace","_onClientsChange","warn","all","setFormsEnabledInConfig","formsEnabledInConfig","_formsEnabledInConfig","setReadStateCallbacks","readStateCallbacks","_readStateCallbacks","setAnnotationCallbacks","annotationCallbacks","_annotationCallbacks","setBookmarkCallbacks","bookmarkCallbacks","_bookmarkCallbacks","setFormFieldCallbacks","formFieldCallbacks","_formFieldCallbacks","setFormFieldValueCallbacks","formFieldValueCallbacks","_formFieldValueCallbacks","setCommentCallbacks","commentCallbacks","_commentCallbacks","createAnnotation","annotation","serializeAnnotation","attachmentsToObject","createComment","add","async","e","deleteComment","commentId","setStateGetter","_getState","backend","isCollaborationPermissionsEnabled","edit","setGroup","deleteAnnotation","createBookmark","bookmark","serializeBookmark","deleteBookmark","bookmarkId","createFormField","formField","serializeFormField","deleteFormField","loadFormFields","loadAnnotationsForPageIndex","createFormFieldValue","formFieldValue","serializeFormFieldValue","getFormFieldValueID","deleteFormFieldValue","_loadPromise","u","d","_onRecordsUpdates","CREATE_REASON_NEW","_onAcceptedRecords","CREATE_REASON_LOAD","_filterRecords","records","isFormFieldJSON","createReason","mutableBookmarkAdditions","mutableFormFieldAdditions","mutableFormFieldValueAdditions","mutableCommentAdditions","deletions","bookmarkDeletions","formFieldDeletions","formFieldValueDeletions","commentDeletions","_created","_updated","_deleted","updatesIndexToBeRemoved","index","_record","annotations","additions","mutableAdditions","deserializeFormField","isFormFieldValueJSON","deserializeFormFieldValue","isBookmarkJSON","deserializeBookmark","isCommentJSON","isSignatureInfoJSON","isEmbeddedFileJSON","deserializeAnnotation","info","showSignatures","shouldShowSignatureFields","features","signatureFeatureAvailability","length","createFormFields","SignatureFormField","size","WidgetAnnotation","field","formFields","createAnnotations","createFormFieldValues","createComments","createBookmarks","mutableBookmarkChanges","asMutable","mutableFormFieldChanges","mutableFormFieldValueChanges","mutableCommentChanges","updates","mutableUpdates","updateAnnotations","updateBookmarks","updateFormFields","setFormFieldValues","updateComments","toSet","deleteAnnotations","isBookmarkDeletion","deleteBookmarks","isFormFieldDeletion","deleteFormFields","isFormFieldValueDeletion","deleteFormFieldValues","commentDeletion","deleteComments","annotationsUpdates","commentsUpdates","formFieldsUpdates","deletableAnnotations","deletableComments","deletableFormFields","mergePermissionsOnRecords","entity","collaborationPermissions","merge","Annotation","view","FormField","isEmpty","onClientsChange","onClientsChangeCallback","call","setDocumentHandleConflictCallback","setDocumentHandleOutdated","_setDocumentHandleOutdatedCallback"],"sourceRoot":""}